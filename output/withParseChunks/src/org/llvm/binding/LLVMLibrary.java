package org.llvm.binding;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.TypedPointer;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>LLVM</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("LLVM") 
@Runtime(CRuntime.class) 
public class LLVMLibrary {
	static {
		BridJ.register();
	}
	/// enum values
	public enum LLVMAttribute implements IntValuedEnum<LLVMAttribute > {
		LLVMZExtAttribute(1 << 0),
		LLVMSExtAttribute(1 << 1),
		LLVMNoReturnAttribute(1 << 2),
		LLVMInRegAttribute(1 << 3),
		LLVMStructRetAttribute(1 << 4),
		LLVMNoUnwindAttribute(1 << 5),
		LLVMNoAliasAttribute(1 << 6),
		LLVMByValAttribute(1 << 7),
		LLVMNestAttribute(1 << 8),
		LLVMReadNoneAttribute(1 << 9),
		LLVMReadOnlyAttribute(1 << 10),
		LLVMNoInlineAttribute(1 << 11),
		LLVMAlwaysInlineAttribute(1 << 12),
		LLVMOptimizeForSizeAttribute(1 << 13),
		LLVMStackProtectAttribute(1 << 14),
		LLVMStackProtectReqAttribute(1 << 15),
		LLVMAlignment(31 << 16),
		LLVMNoCaptureAttribute(1 << 21),
		LLVMNoRedZoneAttribute(1 << 22),
		LLVMNoImplicitFloatAttribute(1 << 23),
		LLVMNakedAttribute(1 << 24),
		LLVMInlineHintAttribute(1 << 25),
		LLVMStackAlignment(7 << 26),
		LLVMReturnsTwice(1 << 29),
		LLVMUWTable(1 << 30),
		LLVMNonLazyBind(1 << 31);
		LLVMAttribute(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMAttribute > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMAttribute > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMOpcode implements IntValuedEnum<LLVMOpcode > {
		/// Terminator Instructions
		LLVMRet(1),
		LLVMBr(2),
		LLVMSwitch(3),
		LLVMIndirectBr(4),
		LLVMInvoke(5),
		/// removed 6 due to API changes
		LLVMUnreachable(7),
		/// Standard Binary Operators
		LLVMAdd(8),
		LLVMFAdd(9),
		LLVMSub(10),
		LLVMFSub(11),
		LLVMMul(12),
		LLVMFMul(13),
		LLVMUDiv(14),
		LLVMSDiv(15),
		LLVMFDiv(16),
		LLVMURem(17),
		LLVMSRem(18),
		LLVMFRem(19),
		/// Logical Operators
		LLVMShl(20),
		LLVMLShr(21),
		LLVMAShr(22),
		LLVMAnd(23),
		LLVMOr(24),
		LLVMXor(25),
		/// Memory Operators
		LLVMAlloca(26),
		LLVMLoad(27),
		LLVMStore(28),
		LLVMGetElementPtr(29),
		/// Cast Operators
		LLVMTrunc(30),
		LLVMZExt(31),
		LLVMSExt(32),
		LLVMFPToUI(33),
		LLVMFPToSI(34),
		LLVMUIToFP(35),
		LLVMSIToFP(36),
		LLVMFPTrunc(37),
		LLVMFPExt(38),
		LLVMPtrToInt(39),
		LLVMIntToPtr(40),
		LLVMBitCast(41),
		/// Other Operators
		LLVMICmp(42),
		LLVMFCmp(43),
		LLVMPHI(44),
		LLVMCall(45),
		LLVMSelect(46),
		LLVMUserOp1(47),
		LLVMUserOp2(48),
		LLVMVAArg(49),
		LLVMExtractElement(50),
		LLVMInsertElement(51),
		LLVMShuffleVector(52),
		LLVMExtractValue(53),
		LLVMInsertValue(54),
		/// Atomic operators
		LLVMFence(55),
		LLVMAtomicCmpXchg(56),
		LLVMAtomicRMW(57),
		/// Exception Handling Operators
		LLVMResume(58),
		LLVMLandingPad(59);
		LLVMOpcode(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMOpcode > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMOpcode > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMTypeKind implements IntValuedEnum<LLVMTypeKind > {
		/// < type with no size
		LLVMVoidTypeKind(0),
		/// < 16 bit floating point type
		LLVMHalfTypeKind(1),
		/// < 32 bit floating point type
		LLVMFloatTypeKind(2),
		/// < 64 bit floating point type
		LLVMDoubleTypeKind(3),
		/// < 80 bit floating point type (X87)
		LLVMX86_FP80TypeKind(4),
		/// < 128 bit floating point type (112-bit mantissa)
		LLVMFP128TypeKind(5),
		/// < 128 bit floating point type (two 64-bits)
		LLVMPPC_FP128TypeKind(6),
		/// < Labels
		LLVMLabelTypeKind(7),
		/// < Arbitrary bit width integers
		LLVMIntegerTypeKind(8),
		/// < Functions
		LLVMFunctionTypeKind(9),
		/// < Structures
		LLVMStructTypeKind(10),
		/// < Arrays
		LLVMArrayTypeKind(11),
		/// < Pointers
		LLVMPointerTypeKind(12),
		/// < SIMD 'packed' format, or other vector type
		LLVMVectorTypeKind(13),
		/// < Metadata
		LLVMMetadataTypeKind(14),
		/// < X86 MMX
		LLVMX86_MMXTypeKind(15);
		LLVMTypeKind(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMTypeKind > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMTypeKind > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMLinkage implements IntValuedEnum<LLVMLinkage > {
		/// < Externally visible function
		LLVMExternalLinkage(0),
		LLVMAvailableExternallyLinkage(1),
		/// < Keep one copy of function when linking (inline)
		LLVMLinkOnceAnyLinkage(2),
		/**
		 * < Same, but only replaced by something<br>
		 * equivalent.
		 */
		LLVMLinkOnceODRLinkage(3),
		/// < Like LinkOnceODR, but possibly hidden.
		LLVMLinkOnceODRAutoHideLinkage(4),
		/// < Keep one copy of function when linking (weak)
		LLVMWeakAnyLinkage(5),
		/**
		 * < Same, but only replaced by something<br>
		 * equivalent.
		 */
		LLVMWeakODRLinkage(6),
		/// < Special purpose, only applies to global arrays
		LLVMAppendingLinkage(7),
		/**
		 * < Rename collisions when linking (static<br>
		 * functions)
		 */
		LLVMInternalLinkage(8),
		/// < Like Internal, but omit from symbol table
		LLVMPrivateLinkage(9),
		/// < Function to be imported from DLL
		LLVMDLLImportLinkage(10),
		/// < Function to be accessible from DLL
		LLVMDLLExportLinkage(11),
		/// < ExternalWeak linkage description
		LLVMExternalWeakLinkage(12),
		/// < Obsolete
		LLVMGhostLinkage(13),
		/// < Tentative definitions
		LLVMCommonLinkage(14),
		/// < Like Private, but linker removes.
		LLVMLinkerPrivateLinkage(15),
		/// < Like LinkerPrivate, but is weak.
		LLVMLinkerPrivateWeakLinkage(16);
		LLVMLinkage(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMLinkage > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMLinkage > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMVisibility implements IntValuedEnum<LLVMVisibility > {
		/// < The GV is visible
		LLVMDefaultVisibility(0),
		/// < The GV is hidden
		LLVMHiddenVisibility(1),
		/// < The GV is protected
		LLVMProtectedVisibility(2);
		LLVMVisibility(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMVisibility > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMVisibility > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMCallConv implements IntValuedEnum<LLVMCallConv > {
		LLVMCCallConv(0),
		LLVMFastCallConv(8),
		LLVMColdCallConv(9),
		LLVMX86StdcallCallConv(64),
		LLVMX86FastcallCallConv(65);
		LLVMCallConv(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMCallConv > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMCallConv > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMIntPredicate implements IntValuedEnum<LLVMIntPredicate > {
		/// < equal
		LLVMIntEQ(32),
		/// < not equal
		LLVMIntNE(33),
		/// < unsigned greater than
		LLVMIntUGT(34),
		/// < unsigned greater or equal
		LLVMIntUGE(35),
		/// < unsigned less than
		LLVMIntULT(36),
		/// < unsigned less or equal
		LLVMIntULE(37),
		/// < signed greater than
		LLVMIntSGT(38),
		/// < signed greater or equal
		LLVMIntSGE(39),
		/// < signed less than
		LLVMIntSLT(40),
		/// < signed less or equal
		LLVMIntSLE(41);
		LLVMIntPredicate(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMIntPredicate > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMIntPredicate > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMRealPredicate implements IntValuedEnum<LLVMRealPredicate > {
		/// < Always false (always folded)
		LLVMRealPredicateFalse(0),
		/// < True if ordered and equal
		LLVMRealOEQ(1),
		/// < True if ordered and greater than
		LLVMRealOGT(2),
		/// < True if ordered and greater than or equal
		LLVMRealOGE(3),
		/// < True if ordered and less than
		LLVMRealOLT(4),
		/// < True if ordered and less than or equal
		LLVMRealOLE(5),
		/// < True if ordered and operands are unequal
		LLVMRealONE(6),
		/// < True if ordered (no nans)
		LLVMRealORD(7),
		/// < True if unordered: isnan(X) | isnan(Y)
		LLVMRealUNO(8),
		/// < True if unordered or equal
		LLVMRealUEQ(9),
		/// < True if unordered or greater than
		LLVMRealUGT(10),
		/// < True if unordered, greater than, or equal
		LLVMRealUGE(11),
		/// < True if unordered or less than
		LLVMRealULT(12),
		/// < True if unordered, less than, or equal
		LLVMRealULE(13),
		/// < True if unordered or not equal
		LLVMRealUNE(14),
		/// < Always true (always folded)
		LLVMRealPredicateTrue(15);
		LLVMRealPredicate(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMRealPredicate > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMRealPredicate > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMLandingPadClauseTy implements IntValuedEnum<LLVMLandingPadClauseTy > {
		/// < A catch clause
		LLVMLandingPadCatch(0),
		/// < A filter clause
		LLVMLandingPadFilter(1);
		LLVMLandingPadClauseTy(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMLandingPadClauseTy > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMLandingPadClauseTy > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMThreadLocalMode implements IntValuedEnum<LLVMThreadLocalMode > {
		LLVMNotThreadLocal(0),
		LLVMGeneralDynamicTLSModel(1),
		LLVMLocalDynamicTLSModel(2),
		LLVMInitialExecTLSModel(3),
		LLVMLocalExecTLSModel(4);
		LLVMThreadLocalMode(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMThreadLocalMode > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMThreadLocalMode > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMAtomicOrdering implements IntValuedEnum<LLVMAtomicOrdering > {
		/// < A load or store which is not atomic
		LLVMAtomicOrderingNotAtomic(0),
		/**
		 * < Lowest level of atomicity, guarantees<br>
		 * somewhat sane results, lock free.
		 */
		LLVMAtomicOrderingUnordered(1),
		/**
		 * < guarantees that if you take all the <br>
		 * operations affecting a specific address, <br>
		 * a consistent ordering exists
		 */
		LLVMAtomicOrderingMonotonic(2),
		/**
		 * < Acquire provides a barrier of the sort <br>
		 * necessary to acquire a lock to access other <br>
		 * memory with normal loads and stores.
		 */
		LLVMAtomicOrderingAcquire(4),
		/**
		 * < Release is similar to Acquire, but with <br>
		 * a barrier of the sort necessary to release <br>
		 * a lock.
		 */
		LLVMAtomicOrderingRelease(5),
		/**
		 * < provides both an Acquire and a <br>
		 * Release barrier (for fences and <br>
		 * operations which both read and write<br>
		 * memory).
		 */
		LLVMAtomicOrderingAcquireRelease(6),
		/**
		 * < provides Acquire semantics <br>
		 * for loads and Release <br>
		 * semantics for stores. <br>
		 * Additionally, it guarantees <br>
		 * that a total ordering exists <br>
		 * between all <br>
		 * SequentiallyConsistent <br>
		 * operations.
		 */
		LLVMAtomicOrderingSequentiallyConsistent(7);
		LLVMAtomicOrdering(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMAtomicOrdering > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMAtomicOrdering > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// enum values
	public enum LLVMAtomicRMWBinOp implements IntValuedEnum<LLVMAtomicRMWBinOp > {
		/// < Set the new value and return the one old
		LLVMAtomicRMWBinOpXchg(0),
		/// < Add a value and return the old one
		LLVMAtomicRMWBinOpAdd(1),
		/// < Subtract a value and return the old one
		LLVMAtomicRMWBinOpSub(2),
		/// < And a value and return the old one
		LLVMAtomicRMWBinOpAnd(3),
		/// < Not-And a value and return the old one
		LLVMAtomicRMWBinOpNand(4),
		/// < OR a value and return the old one
		LLVMAtomicRMWBinOpOr(5),
		/// < Xor a value and return the old one
		LLVMAtomicRMWBinOpXor(6),
		/**
		 * < Sets the value if it's greater than the<br>
		 * original using a signed comparison and return <br>
		 * the old one
		 */
		LLVMAtomicRMWBinOpMax(7),
		/**
		 * < Sets the value if it's Smaller than the<br>
		 * original using a signed comparison and return <br>
		 * the old one
		 */
		LLVMAtomicRMWBinOpMin(8),
		/**
		 * < Sets the value if it's greater than the<br>
		 * original using an unsigned comparison and return <br>
		 * the old one
		 */
		LLVMAtomicRMWBinOpUMax(9),
		/**
		 * < Sets the value if it's greater than the<br>
		 * original using an unsigned comparison  and return <br>
		 * the old one
		 */
		LLVMAtomicRMWBinOpUMin(10);
		LLVMAtomicRMWBinOp(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<LLVMAtomicRMWBinOp > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<LLVMAtomicRMWBinOp > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	public static final int LLVMDisassembler_VariantKind_None = (int)0;
	public static final int LLVMDisassembler_Option_PrintImmHex = (int)2;
	public static final int LLVMDisassembler_VariantKind_ARM_HI16 = (int)1;
	public static final int LLVMDisassembler_VariantKind_ARM_LO16 = (int)2;
	public static final int LLVMDisassembler_ReferenceType_Out_LitPool_SymAddr = (int)2;
	public static final int LLVMDisassembler_ReferenceType_In_PCrel_Load = (int)2;
	public static final int LLVMDisassembler_ReferenceType_In_Branch = (int)1;
	public static final int LLVMDisassembler_Option_AsmPrinterVariant = (int)4;
	public static final int LLVMDisassembler_ReferenceType_Out_LitPool_CstrAddr = (int)3;
	public static final int LLVMDisassembler_Option_UseMarkup = (int)1;
	public static final int LLVMDisassembler_ReferenceType_InOut_None = (int)0;
	public static final int LLVMDisassembler_ReferenceType_Out_SymbolStub = (int)1;
	/**
	 * The type for the operand information call back function.  This is called to<br>
	 * get the symbolic information for an operand of an instruction.  Typically<br>
	 * this is from the relocation information, symbol table, etc.  That block of<br>
	 * information is saved when the disassembler context is created and passed to<br>
	 * the call back in the DisInfo parameter.  The instruction containing operand<br>
	 * is at the PC parameter.  For some instruction sets, there can be more than<br>
	 * one operand with symbolic information.  To determine the symbolic operand<br>
	 * information for each operand, the bytes for the specific operand in the<br>
	 * instruction are specified by the Offset parameter and its byte widith is the<br>
	 * size parameter.  For instructions sets with fixed widths and one symbolic<br>
	 * operand per instruction, the Offset parameter will be zero and Size parameter<br>
	 * will be the instruction width.  The information is returned in TagBuf and is <br>
	 * Triple specific with its specific information defined by the value of<br>
	 * TagType for that Triple.  If symbolic information is returned the function<br>
	 * returns 1, otherwise it returns 0.
	 */
	/**
	 * The type for the operand information call back function.  This is called to<br>
	 * get the symbolic information for an operand of an instruction.  Typically<br>
	 * this is from the relocation information, symbol table, etc.  That block of<br>
	 * information is saved when the disassembler context is created and passed to<br>
	 * the call back in the DisInfo parameter.  The instruction containing operand<br>
	 * is at the PC parameter.  For some instruction sets, there can be more than<br>
	 * one operand with symbolic information.  To determine the symbolic operand<br>
	 * information for each operand, the bytes for the specific operand in the<br>
	 * instruction are specified by the Offset parameter and its byte widith is the<br>
	 * size parameter.  For instructions sets with fixed widths and one symbolic<br>
	 * operand per instruction, the Offset parameter will be zero and Size parameter<br>
	 * will be the instruction width.  The information is returned in TagBuf and is <br>
	 * Triple specific with its specific information defined by the value of<br>
	 * TagType for that Triple.  If symbolic information is returned the function<br>
	 * returns 1, otherwise it returns 0.
	 */
	public static abstract class LLVMOpInfoCallback extends Callback<LLVMOpInfoCallback > {
		abstract public int apply(Pointer<? > DisInfo, long PC, long Offset, long Size, int TagType, Pointer<? > TagBuf);
	};
	/**
	 * The type for the symbol lookup function.  This may be called by the<br>
	 * disassembler for things like adding a comment for a PC plus a constant<br>
	 * offset load instruction to use a symbol name instead of a load address value.<br>
	 * It is passed the block information is saved when the disassembler context is<br>
	 * created and the ReferenceValue to look up as a symbol.  If no symbol is found<br>
	 * for the ReferenceValue NULL is returned.  The ReferenceType of the<br>
	 * instruction is passed indirectly as is the PC of the instruction in<br>
	 * ReferencePC.  If the output reference can be determined its type is returned<br>
	 * indirectly in ReferenceType along with ReferenceName if any, or that is set<br>
	 * to NULL.
	 */
	/**
	 * The type for the symbol lookup function.  This may be called by the<br>
	 * disassembler for things like adding a comment for a PC plus a constant<br>
	 * offset load instruction to use a symbol name instead of a load address value.<br>
	 * It is passed the block information is saved when the disassembler context is<br>
	 * created and the ReferenceValue to look up as a symbol.  If no symbol is found<br>
	 * for the ReferenceValue NULL is returned.  The ReferenceType of the<br>
	 * instruction is passed indirectly as is the PC of the instruction in<br>
	 * ReferencePC.  If the output reference can be determined its type is returned<br>
	 * indirectly in ReferenceType along with ReferenceName if any, or that is set<br>
	 * to NULL.
	 */
	public static abstract class LLVMSymbolLookupCallback extends Callback<LLVMSymbolLookupCallback > {
		abstract public Pointer<Byte > apply(Pointer<? > DisInfo, long ReferenceValue, Pointer<Long > ReferenceType, long ReferencePC, Pointer<Pointer<Byte > > ReferenceName);
	};
	/// Original signature : <code>void LLVMInitializeCore(LLVMPassRegistryRef)</code>
	public static void LLVMInitializeCore(LLVMLibrary.LLVMPassRegistryRef R) {
		LLVMInitializeCore(Pointer.getPeer(R));
	}
	protected native static void LLVMInitializeCore(@Ptr long R);
	/**
	 * Deallocate and destroy all ManagedStatic variables.<br>
	 * @see llvm::llvm_shutdown<br>
	 * @see ManagedStatic<br>
	 * Original signature : <code>void LLVMShutdown()</code>
	 */
	native public static void LLVMShutdown();
	/// Original signature : <code>void LLVMDisposeMessage(char*)</code>
	public static void LLVMDisposeMessage(Pointer<Byte > Message) {
		LLVMDisposeMessage(Pointer.getPeer(Message));
	}
	protected native static void LLVMDisposeMessage(@Ptr long Message);
	/**
	 * Create a new context.<br>
	 * * Every call to this function should be paired with a call to<br>
	 * LLVMContextDispose() or the context will leak memory.<br>
	 * Original signature : <code>LLVMContextRef LLVMContextCreate()</code>
	 */
	public static LLVMLibrary.LLVMContextRef LLVMContextCreate() {
		return new LLVMLibrary.LLVMContextRef(LLVMContextCreate$2());
	}
	@Ptr 
	@Name("LLVMContextCreate") 
	protected native static long LLVMContextCreate$2();
	/**
	 * Obtain the global context instance.<br>
	 * Original signature : <code>LLVMContextRef LLVMGetGlobalContext()</code>
	 */
	public static LLVMLibrary.LLVMContextRef LLVMGetGlobalContext() {
		return new LLVMLibrary.LLVMContextRef(LLVMGetGlobalContext$2());
	}
	@Ptr 
	@Name("LLVMGetGlobalContext") 
	protected native static long LLVMGetGlobalContext$2();
	/**
	 * Destroy a context instance.<br>
	 * * This should be called for every call to LLVMContextCreate() or memory<br>
	 * will be leaked.<br>
	 * Original signature : <code>void LLVMContextDispose(LLVMContextRef)</code>
	 */
	public static void LLVMContextDispose(LLVMLibrary.LLVMContextRef C) {
		LLVMContextDispose(Pointer.getPeer(C));
	}
	protected native static void LLVMContextDispose(@Ptr long C);
	/// Original signature : <code>int LLVMGetMDKindIDInContext(LLVMContextRef, const char*, unsigned)</code>
	public static int LLVMGetMDKindIDInContext(LLVMLibrary.LLVMContextRef C, Pointer<Byte > Name, int SLen) {
		return LLVMGetMDKindIDInContext(Pointer.getPeer(C), Pointer.getPeer(Name), SLen);
	}
	protected native static int LLVMGetMDKindIDInContext(@Ptr long C, @Ptr long Name, int SLen);
	/// Original signature : <code>int LLVMGetMDKindID(const char*, unsigned)</code>
	public static int LLVMGetMDKindID(Pointer<Byte > Name, int SLen) {
		return LLVMGetMDKindID(Pointer.getPeer(Name), SLen);
	}
	protected native static int LLVMGetMDKindID(@Ptr long Name, int SLen);
	/**
	 * Create a new, empty module in the global context.<br>
	 * * This is equivalent to calling LLVMModuleCreateWithNameInContext with<br>
	 * LLVMGetGlobalContext() as the context parameter.<br>
	 * * Every invocation should be paired with LLVMDisposeModule() or memory<br>
	 * will be leaked.<br>
	 * Original signature : <code>LLVMModuleRef LLVMModuleCreateWithName(const char*)</code>
	 */
	public static LLVMLibrary.LLVMModuleRef LLVMModuleCreateWithName(Pointer<Byte > ModuleID) {
		return new LLVMLibrary.LLVMModuleRef(LLVMModuleCreateWithName(Pointer.getPeer(ModuleID)));
	}
	@Ptr 
	protected native static long LLVMModuleCreateWithName(@Ptr long ModuleID);
	/**
	 * Create a new, empty module in a specific context.<br>
	 * * Every invocation should be paired with LLVMDisposeModule() or memory<br>
	 * will be leaked.<br>
	 * Original signature : <code>LLVMModuleRef LLVMModuleCreateWithNameInContext(const char*, LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMModuleRef LLVMModuleCreateWithNameInContext(Pointer<Byte > ModuleID, LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMModuleRef(LLVMModuleCreateWithNameInContext(Pointer.getPeer(ModuleID), Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMModuleCreateWithNameInContext(@Ptr long ModuleID, @Ptr long C);
	/**
	 * Destroy a module instance.<br>
	 * * This must be called for every created module or memory will be<br>
	 * leaked.<br>
	 * Original signature : <code>void LLVMDisposeModule(LLVMModuleRef)</code>
	 */
	public static void LLVMDisposeModule(LLVMLibrary.LLVMModuleRef M) {
		LLVMDisposeModule(Pointer.getPeer(M));
	}
	protected native static void LLVMDisposeModule(@Ptr long M);
	/**
	 * Obtain the data layout for a module.<br>
	 * * @see Module::getDataLayout()<br>
	 * Original signature : <code>char* LLVMGetDataLayout(LLVMModuleRef)</code>
	 */
	public static Pointer<Byte > LLVMGetDataLayout(LLVMLibrary.LLVMModuleRef M) {
		return Pointer.pointerToAddress(LLVMGetDataLayout(Pointer.getPeer(M)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetDataLayout(@Ptr long M);
	/**
	 * Set the data layout for a module.<br>
	 * * @see Module::setDataLayout()<br>
	 * Original signature : <code>void LLVMSetDataLayout(LLVMModuleRef, const char*)</code>
	 */
	public static void LLVMSetDataLayout(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Triple) {
		LLVMSetDataLayout(Pointer.getPeer(M), Pointer.getPeer(Triple));
	}
	protected native static void LLVMSetDataLayout(@Ptr long M, @Ptr long Triple);
	/**
	 * Obtain the target triple for a module.<br>
	 * * @see Module::getTargetTriple()<br>
	 * Original signature : <code>char* LLVMGetTarget(LLVMModuleRef)</code>
	 */
	public static Pointer<Byte > LLVMGetTarget(LLVMLibrary.LLVMModuleRef M) {
		return Pointer.pointerToAddress(LLVMGetTarget(Pointer.getPeer(M)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetTarget(@Ptr long M);
	/**
	 * Set the target triple for a module.<br>
	 * * @see Module::setTargetTriple()<br>
	 * Original signature : <code>void LLVMSetTarget(LLVMModuleRef, const char*)</code>
	 */
	public static void LLVMSetTarget(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Triple) {
		LLVMSetTarget(Pointer.getPeer(M), Pointer.getPeer(Triple));
	}
	protected native static void LLVMSetTarget(@Ptr long M, @Ptr long Triple);
	/**
	 * Dump a representation of a module to stderr.<br>
	 * * @see Module::dump()<br>
	 * Original signature : <code>void LLVMDumpModule(LLVMModuleRef)</code>
	 */
	public static void LLVMDumpModule(LLVMLibrary.LLVMModuleRef M) {
		LLVMDumpModule(Pointer.getPeer(M));
	}
	protected native static void LLVMDumpModule(@Ptr long M);
	/**
	 * Print a representation of a module to a file. The ErrorMessage needs to be<br>
	 * disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.<br>
	 * * @see Module::print()<br>
	 * Original signature : <code>LLVMBool LLVMPrintModuleToFile(LLVMModuleRef, const char*, char**)</code>
	 */
	public static int LLVMPrintModuleToFile(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Filename, Pointer<Pointer<Byte > > ErrorMessage) {
		return LLVMPrintModuleToFile(Pointer.getPeer(M), Pointer.getPeer(Filename), Pointer.getPeer(ErrorMessage));
	}
	protected native static int LLVMPrintModuleToFile(@Ptr long M, @Ptr long Filename, @Ptr long ErrorMessage);
	/**
	 * Set inline assembly for a module.<br>
	 * * @see Module::setModuleInlineAsm()<br>
	 * Original signature : <code>void LLVMSetModuleInlineAsm(LLVMModuleRef, const char*)</code>
	 */
	public static void LLVMSetModuleInlineAsm(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Asm) {
		LLVMSetModuleInlineAsm(Pointer.getPeer(M), Pointer.getPeer(Asm));
	}
	protected native static void LLVMSetModuleInlineAsm(@Ptr long M, @Ptr long Asm);
	/**
	 * Obtain the context to which this module is associated.<br>
	 * * @see Module::getContext()<br>
	 * Original signature : <code>LLVMContextRef LLVMGetModuleContext(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMContextRef LLVMGetModuleContext(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMContextRef(LLVMGetModuleContext(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetModuleContext(@Ptr long M);
	/**
	 * Obtain a Type from a module by its registered name.<br>
	 * Original signature : <code>LLVMTypeRef LLVMGetTypeByName(LLVMModuleRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMGetTypeByName(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMTypeRef(LLVMGetTypeByName(Pointer.getPeer(M), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMGetTypeByName(@Ptr long M, @Ptr long Name);
	/**
	 * Obtain the number of operands for named metadata in a module.<br>
	 * * @see llvm::Module::getNamedMetadata()<br>
	 * Original signature : <code>int LLVMGetNamedMetadataNumOperands(LLVMModuleRef, const char*)</code>
	 */
	public static int LLVMGetNamedMetadataNumOperands(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > name) {
		return LLVMGetNamedMetadataNumOperands(Pointer.getPeer(M), Pointer.getPeer(name));
	}
	protected native static int LLVMGetNamedMetadataNumOperands(@Ptr long M, @Ptr long name);
	/**
	 * Obtain the named metadata operands for a module.<br>
	 * * The passed LLVMValueRef pointer should refer to an array of<br>
	 * LLVMValueRef at least LLVMGetNamedMetadataNumOperands long. This<br>
	 * array will be populated with the LLVMValueRef instances. Each<br>
	 * instance corresponds to a llvm::MDNode.<br>
	 * * @see llvm::Module::getNamedMetadata()<br>
	 * @see llvm::MDNode::getOperand()<br>
	 * Original signature : <code>void LLVMGetNamedMetadataOperands(LLVMModuleRef, const char*, LLVMValueRef*)</code>
	 */
	public static void LLVMGetNamedMetadataOperands(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > name, Pointer<LLVMLibrary.LLVMValueRef > Dest) {
		LLVMGetNamedMetadataOperands(Pointer.getPeer(M), Pointer.getPeer(name), Pointer.getPeer(Dest));
	}
	protected native static void LLVMGetNamedMetadataOperands(@Ptr long M, @Ptr long name, @Ptr long Dest);
	/**
	 * Add an operand to named metadata.<br>
	 * * @see llvm::Module::getNamedMetadata()<br>
	 * @see llvm::MDNode::addOperand()<br>
	 * Original signature : <code>void LLVMAddNamedMetadataOperand(LLVMModuleRef, const char*, LLVMValueRef)</code>
	 */
	public static void LLVMAddNamedMetadataOperand(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > name, LLVMLibrary.LLVMValueRef Val) {
		LLVMAddNamedMetadataOperand(Pointer.getPeer(M), Pointer.getPeer(name), Pointer.getPeer(Val));
	}
	protected native static void LLVMAddNamedMetadataOperand(@Ptr long M, @Ptr long name, @Ptr long Val);
	/**
	 * Add a function to a module under a specified name.<br>
	 * * @see llvm::Function::Create()<br>
	 * Original signature : <code>LLVMValueRef LLVMAddFunction(LLVMModuleRef, const char*, LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMAddFunction(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name, LLVMLibrary.LLVMTypeRef FunctionTy) {
		return new LLVMLibrary.LLVMValueRef(LLVMAddFunction(Pointer.getPeer(M), Pointer.getPeer(Name), Pointer.getPeer(FunctionTy)));
	}
	@Ptr 
	protected native static long LLVMAddFunction(@Ptr long M, @Ptr long Name, @Ptr long FunctionTy);
	/**
	 * Obtain a Function value from a Module by its name.<br>
	 * * The returned value corresponds to a llvm::Function value.<br>
	 * * @see llvm::Module::getFunction()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetNamedFunction(LLVMModuleRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetNamedFunction(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNamedFunction(Pointer.getPeer(M), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMGetNamedFunction(@Ptr long M, @Ptr long Name);
	/**
	 * Obtain an iterator to the first Function in a Module.<br>
	 * * @see llvm::Module::begin()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetFirstFunction(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetFirstFunction(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetFirstFunction(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetFirstFunction(@Ptr long M);
	/**
	 * Obtain an iterator to the last Function in a Module.<br>
	 * * @see llvm::Module::end()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetLastFunction(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetLastFunction(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetLastFunction(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetLastFunction(@Ptr long M);
	/**
	 * Advance a Function iterator to the next Function.<br>
	 * * Returns NULL if the iterator was already at the end and there are no more<br>
	 * functions.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetNextFunction(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetNextFunction(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNextFunction(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetNextFunction(@Ptr long Fn);
	/**
	 * Decrement a Function iterator to the previous Function.<br>
	 * * Returns NULL if the iterator was already at the beginning and there are<br>
	 * no previous functions.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetPreviousFunction(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetPreviousFunction(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetPreviousFunction(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousFunction(@Ptr long Fn);
	/**
	 * Obtain the enumerated type of a Type instance.<br>
	 * * @see llvm::Type:getTypeID()<br>
	 * Original signature : <code>LLVMTypeKind LLVMGetTypeKind(LLVMTypeRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMTypeKind > LLVMGetTypeKind(LLVMLibrary.LLVMTypeRef Ty) {
		return FlagSet.fromValue(LLVMGetTypeKind(Pointer.getPeer(Ty)), LLVMLibrary.LLVMTypeKind.class);
	}
	protected native static int LLVMGetTypeKind(@Ptr long Ty);
	/**
	 * Whether the type has a known size.<br>
	 * * Things that don't have a size are abstract types, labels, and void.a<br>
	 * * @see llvm::Type::isSized()<br>
	 * Original signature : <code>LLVMBool LLVMTypeIsSized(LLVMTypeRef)</code>
	 */
	public static int LLVMTypeIsSized(LLVMLibrary.LLVMTypeRef Ty) {
		return LLVMTypeIsSized(Pointer.getPeer(Ty));
	}
	protected native static int LLVMTypeIsSized(@Ptr long Ty);
	/**
	 * Obtain the context to which this type instance is associated.<br>
	 * * @see llvm::Type::getContext()<br>
	 * Original signature : <code>LLVMContextRef LLVMGetTypeContext(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMContextRef LLVMGetTypeContext(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMContextRef(LLVMGetTypeContext(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMGetTypeContext(@Ptr long Ty);
	/**
	 * Obtain an integer type from a context with specified bit width.<br>
	 * Original signature : <code>LLVMTypeRef LLVMInt1TypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMInt1TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt1TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt1TypeInContext(@Ptr long C);
	/// Original signature : <code>LLVMTypeRef LLVMInt8TypeInContext(LLVMContextRef)</code>
	public static LLVMLibrary.LLVMTypeRef LLVMInt8TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt8TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt8TypeInContext(@Ptr long C);
	/// Original signature : <code>LLVMTypeRef LLVMInt16TypeInContext(LLVMContextRef)</code>
	public static LLVMLibrary.LLVMTypeRef LLVMInt16TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt16TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt16TypeInContext(@Ptr long C);
	/// Original signature : <code>LLVMTypeRef LLVMInt32TypeInContext(LLVMContextRef)</code>
	public static LLVMLibrary.LLVMTypeRef LLVMInt32TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt32TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt32TypeInContext(@Ptr long C);
	/// Original signature : <code>LLVMTypeRef LLVMInt64TypeInContext(LLVMContextRef)</code>
	public static LLVMLibrary.LLVMTypeRef LLVMInt64TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt64TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMInt64TypeInContext(@Ptr long C);
	/// Original signature : <code>LLVMTypeRef LLVMIntTypeInContext(LLVMContextRef, unsigned)</code>
	public static LLVMLibrary.LLVMTypeRef LLVMIntTypeInContext(LLVMLibrary.LLVMContextRef C, int NumBits) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntTypeInContext(Pointer.getPeer(C), NumBits));
	}
	@Ptr 
	protected native static long LLVMIntTypeInContext(@Ptr long C, int NumBits);
	/**
	 * Obtain an integer type from the global context with a specified bit<br>
	 * width.<br>
	 * Original signature : <code>LLVMTypeRef LLVMInt1Type()</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMInt1Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt1Type$2());
	}
	@Ptr 
	@Name("LLVMInt1Type") 
	protected native static long LLVMInt1Type$2();
	/// Original signature : <code>LLVMTypeRef LLVMInt8Type()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMInt8Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt8Type$2());
	}
	@Ptr 
	@Name("LLVMInt8Type") 
	protected native static long LLVMInt8Type$2();
	/// Original signature : <code>LLVMTypeRef LLVMInt16Type()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMInt16Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt16Type$2());
	}
	@Ptr 
	@Name("LLVMInt16Type") 
	protected native static long LLVMInt16Type$2();
	/// Original signature : <code>LLVMTypeRef LLVMInt32Type()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMInt32Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt32Type$2());
	}
	@Ptr 
	@Name("LLVMInt32Type") 
	protected native static long LLVMInt32Type$2();
	/// Original signature : <code>LLVMTypeRef LLVMInt64Type()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMInt64Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMInt64Type$2());
	}
	@Ptr 
	@Name("LLVMInt64Type") 
	protected native static long LLVMInt64Type$2();
	/// Original signature : <code>LLVMTypeRef LLVMIntType(unsigned)</code>
	public static LLVMLibrary.LLVMTypeRef LLVMIntType(int NumBits) {
		return new LLVMLibrary.LLVMTypeRef(LLVMIntType$2(NumBits));
	}
	@Ptr 
	@Name("LLVMIntType") 
	protected native static long LLVMIntType$2(int NumBits);
	/// Original signature : <code>int LLVMGetIntTypeWidth(LLVMTypeRef)</code>
	public static int LLVMGetIntTypeWidth(LLVMLibrary.LLVMTypeRef IntegerTy) {
		return LLVMGetIntTypeWidth(Pointer.getPeer(IntegerTy));
	}
	protected native static int LLVMGetIntTypeWidth(@Ptr long IntegerTy);
	/**
	 * Obtain a 16-bit floating point type from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMHalfTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMHalfTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMHalfTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMHalfTypeInContext(@Ptr long C);
	/**
	 * Obtain a 32-bit floating point type from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMFloatTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMFloatTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMFloatTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMFloatTypeInContext(@Ptr long C);
	/**
	 * Obtain a 64-bit floating point type from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMDoubleTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMDoubleTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMDoubleTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMDoubleTypeInContext(@Ptr long C);
	/**
	 * Obtain a 80-bit floating point type (X87) from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMX86FP80TypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMX86FP80TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMX86FP80TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMX86FP80TypeInContext(@Ptr long C);
	/**
	 * Obtain a 128-bit floating point type (112-bit mantissa) from a<br>
	 * context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMFP128TypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMFP128TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMFP128TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMFP128TypeInContext(@Ptr long C);
	/**
	 * Obtain a 128-bit floating point type (two 64-bits) from a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMPPCFP128TypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMPPCFP128TypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMPPCFP128TypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMPPCFP128TypeInContext(@Ptr long C);
	/**
	 * Obtain a floating point type from the global context.<br>
	 * * These map to the functions in this group of the same name.<br>
	 * Original signature : <code>LLVMTypeRef LLVMHalfType()</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMHalfType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMHalfType$2());
	}
	@Ptr 
	@Name("LLVMHalfType") 
	protected native static long LLVMHalfType$2();
	/// Original signature : <code>LLVMTypeRef LLVMFloatType()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMFloatType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMFloatType$2());
	}
	@Ptr 
	@Name("LLVMFloatType") 
	protected native static long LLVMFloatType$2();
	/// Original signature : <code>LLVMTypeRef LLVMDoubleType()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMDoubleType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMDoubleType$2());
	}
	@Ptr 
	@Name("LLVMDoubleType") 
	protected native static long LLVMDoubleType$2();
	/// Original signature : <code>LLVMTypeRef LLVMX86FP80Type()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMX86FP80Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMX86FP80Type$2());
	}
	@Ptr 
	@Name("LLVMX86FP80Type") 
	protected native static long LLVMX86FP80Type$2();
	/// Original signature : <code>LLVMTypeRef LLVMFP128Type()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMFP128Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMFP128Type$2());
	}
	@Ptr 
	@Name("LLVMFP128Type") 
	protected native static long LLVMFP128Type$2();
	/// Original signature : <code>LLVMTypeRef LLVMPPCFP128Type()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMPPCFP128Type() {
		return new LLVMLibrary.LLVMTypeRef(LLVMPPCFP128Type$2());
	}
	@Ptr 
	@Name("LLVMPPCFP128Type") 
	protected native static long LLVMPPCFP128Type$2();
	/**
	 * Obtain a function type consisting of a specified signature.<br>
	 * * The function is defined as a tuple of a return Type, a list of<br>
	 * parameter types, and whether the function is variadic.<br>
	 * Original signature : <code>LLVMTypeRef LLVMFunctionType(LLVMTypeRef, LLVMTypeRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMFunctionType(LLVMLibrary.LLVMTypeRef ReturnType, Pointer<LLVMLibrary.LLVMTypeRef > ParamTypes, int ParamCount, int IsVarArg) {
		return new LLVMLibrary.LLVMTypeRef(LLVMFunctionType(Pointer.getPeer(ReturnType), Pointer.getPeer(ParamTypes), ParamCount, IsVarArg));
	}
	@Ptr 
	protected native static long LLVMFunctionType(@Ptr long ReturnType, @Ptr long ParamTypes, int ParamCount, int IsVarArg);
	/**
	 * Returns whether a function type is variadic.<br>
	 * Original signature : <code>LLVMBool LLVMIsFunctionVarArg(LLVMTypeRef)</code>
	 */
	public static int LLVMIsFunctionVarArg(LLVMLibrary.LLVMTypeRef FunctionTy) {
		return LLVMIsFunctionVarArg(Pointer.getPeer(FunctionTy));
	}
	protected native static int LLVMIsFunctionVarArg(@Ptr long FunctionTy);
	/**
	 * Obtain the Type this function Type returns.<br>
	 * Original signature : <code>LLVMTypeRef LLVMGetReturnType(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMGetReturnType(LLVMLibrary.LLVMTypeRef FunctionTy) {
		return new LLVMLibrary.LLVMTypeRef(LLVMGetReturnType(Pointer.getPeer(FunctionTy)));
	}
	@Ptr 
	protected native static long LLVMGetReturnType(@Ptr long FunctionTy);
	/**
	 * Obtain the number of parameters this function accepts.<br>
	 * Original signature : <code>int LLVMCountParamTypes(LLVMTypeRef)</code>
	 */
	public static int LLVMCountParamTypes(LLVMLibrary.LLVMTypeRef FunctionTy) {
		return LLVMCountParamTypes(Pointer.getPeer(FunctionTy));
	}
	protected native static int LLVMCountParamTypes(@Ptr long FunctionTy);
	/**
	 * Obtain the types of a function's parameters.<br>
	 * * The Dest parameter should point to a pre-allocated array of<br>
	 * LLVMTypeRef at least LLVMCountParamTypes() large. On return, the<br>
	 * first LLVMCountParamTypes() entries in the array will be populated<br>
	 * with LLVMTypeRef instances.<br>
	 * * @param FunctionTy The function type to operate on.<br>
	 * @param Dest Memory address of an array to be filled with result.<br>
	 * Original signature : <code>void LLVMGetParamTypes(LLVMTypeRef, LLVMTypeRef*)</code>
	 */
	public static void LLVMGetParamTypes(LLVMLibrary.LLVMTypeRef FunctionTy, Pointer<LLVMLibrary.LLVMTypeRef > Dest) {
		LLVMGetParamTypes(Pointer.getPeer(FunctionTy), Pointer.getPeer(Dest));
	}
	protected native static void LLVMGetParamTypes(@Ptr long FunctionTy, @Ptr long Dest);
	/**
	 * Create a new structure type in a context.<br>
	 * * A structure is specified by a list of inner elements/types and<br>
	 * whether these can be packed together.<br>
	 * * @see llvm::StructType::create()<br>
	 * Original signature : <code>LLVMTypeRef LLVMStructTypeInContext(LLVMContextRef, LLVMTypeRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMStructTypeInContext(LLVMLibrary.LLVMContextRef C, Pointer<LLVMLibrary.LLVMTypeRef > ElementTypes, int ElementCount, int Packed) {
		return new LLVMLibrary.LLVMTypeRef(LLVMStructTypeInContext(Pointer.getPeer(C), Pointer.getPeer(ElementTypes), ElementCount, Packed));
	}
	@Ptr 
	protected native static long LLVMStructTypeInContext(@Ptr long C, @Ptr long ElementTypes, int ElementCount, int Packed);
	/**
	 * Create a new structure type in the global context.<br>
	 * * @see llvm::StructType::create()<br>
	 * Original signature : <code>LLVMTypeRef LLVMStructType(LLVMTypeRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMStructType(Pointer<LLVMLibrary.LLVMTypeRef > ElementTypes, int ElementCount, int Packed) {
		return new LLVMLibrary.LLVMTypeRef(LLVMStructType(Pointer.getPeer(ElementTypes), ElementCount, Packed));
	}
	@Ptr 
	protected native static long LLVMStructType(@Ptr long ElementTypes, int ElementCount, int Packed);
	/**
	 * Create an empty structure in a context having a specified name.<br>
	 * * @see llvm::StructType::create()<br>
	 * Original signature : <code>LLVMTypeRef LLVMStructCreateNamed(LLVMContextRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMStructCreateNamed(LLVMLibrary.LLVMContextRef C, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMTypeRef(LLVMStructCreateNamed(Pointer.getPeer(C), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMStructCreateNamed(@Ptr long C, @Ptr long Name);
	/**
	 * Obtain the name of a structure.<br>
	 * * @see llvm::StructType::getName()<br>
	 * Original signature : <code>char* LLVMGetStructName(LLVMTypeRef)</code>
	 */
	public static Pointer<Byte > LLVMGetStructName(LLVMLibrary.LLVMTypeRef Ty) {
		return Pointer.pointerToAddress(LLVMGetStructName(Pointer.getPeer(Ty)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetStructName(@Ptr long Ty);
	/**
	 * Set the contents of a structure type.<br>
	 * * @see llvm::StructType::setBody()<br>
	 * Original signature : <code>void LLVMStructSetBody(LLVMTypeRef, LLVMTypeRef*, unsigned, LLVMBool)</code>
	 */
	public static void LLVMStructSetBody(LLVMLibrary.LLVMTypeRef StructTy, Pointer<LLVMLibrary.LLVMTypeRef > ElementTypes, int ElementCount, int Packed) {
		LLVMStructSetBody(Pointer.getPeer(StructTy), Pointer.getPeer(ElementTypes), ElementCount, Packed);
	}
	protected native static void LLVMStructSetBody(@Ptr long StructTy, @Ptr long ElementTypes, int ElementCount, int Packed);
	/**
	 * Get the number of elements defined inside the structure.<br>
	 * * @see llvm::StructType::getNumElements()<br>
	 * Original signature : <code>int LLVMCountStructElementTypes(LLVMTypeRef)</code>
	 */
	public static int LLVMCountStructElementTypes(LLVMLibrary.LLVMTypeRef StructTy) {
		return LLVMCountStructElementTypes(Pointer.getPeer(StructTy));
	}
	protected native static int LLVMCountStructElementTypes(@Ptr long StructTy);
	/**
	 * Get the elements within a structure.<br>
	 * * The function is passed the address of a pre-allocated array of<br>
	 * LLVMTypeRef at least LLVMCountStructElementTypes() long. After<br>
	 * invocation, this array will be populated with the structure's<br>
	 * elements. The objects in the destination array will have a lifetime<br>
	 * of the structure type itself, which is the lifetime of the context it<br>
	 * is contained in.<br>
	 * Original signature : <code>void LLVMGetStructElementTypes(LLVMTypeRef, LLVMTypeRef*)</code>
	 */
	public static void LLVMGetStructElementTypes(LLVMLibrary.LLVMTypeRef StructTy, Pointer<LLVMLibrary.LLVMTypeRef > Dest) {
		LLVMGetStructElementTypes(Pointer.getPeer(StructTy), Pointer.getPeer(Dest));
	}
	protected native static void LLVMGetStructElementTypes(@Ptr long StructTy, @Ptr long Dest);
	/**
	 * Determine whether a structure is packed.<br>
	 * * @see llvm::StructType::isPacked()<br>
	 * Original signature : <code>LLVMBool LLVMIsPackedStruct(LLVMTypeRef)</code>
	 */
	public static int LLVMIsPackedStruct(LLVMLibrary.LLVMTypeRef StructTy) {
		return LLVMIsPackedStruct(Pointer.getPeer(StructTy));
	}
	protected native static int LLVMIsPackedStruct(@Ptr long StructTy);
	/**
	 * Determine whether a structure is opaque.<br>
	 * * @see llvm::StructType::isOpaque()<br>
	 * Original signature : <code>LLVMBool LLVMIsOpaqueStruct(LLVMTypeRef)</code>
	 */
	public static int LLVMIsOpaqueStruct(LLVMLibrary.LLVMTypeRef StructTy) {
		return LLVMIsOpaqueStruct(Pointer.getPeer(StructTy));
	}
	protected native static int LLVMIsOpaqueStruct(@Ptr long StructTy);
	/**
	 * Obtain the type of elements within a sequential type.<br>
	 * * This works on array, vector, and pointer types.<br>
	 * * @see llvm::SequentialType::getElementType()<br>
	 * Original signature : <code>LLVMTypeRef LLVMGetElementType(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMGetElementType(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMTypeRef(LLVMGetElementType(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMGetElementType(@Ptr long Ty);
	/**
	 * Create a fixed size array type that refers to a specific type.<br>
	 * * The created type will exist in the context that its element type<br>
	 * exists in.<br>
	 * * @see llvm::ArrayType::get()<br>
	 * Original signature : <code>LLVMTypeRef LLVMArrayType(LLVMTypeRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMArrayType(LLVMLibrary.LLVMTypeRef ElementType, int ElementCount) {
		return new LLVMLibrary.LLVMTypeRef(LLVMArrayType(Pointer.getPeer(ElementType), ElementCount));
	}
	@Ptr 
	protected native static long LLVMArrayType(@Ptr long ElementType, int ElementCount);
	/**
	 * Obtain the length of an array type.<br>
	 * * This only works on types that represent arrays.<br>
	 * * @see llvm::ArrayType::getNumElements()<br>
	 * Original signature : <code>int LLVMGetArrayLength(LLVMTypeRef)</code>
	 */
	public static int LLVMGetArrayLength(LLVMLibrary.LLVMTypeRef ArrayTy) {
		return LLVMGetArrayLength(Pointer.getPeer(ArrayTy));
	}
	protected native static int LLVMGetArrayLength(@Ptr long ArrayTy);
	/**
	 * Create a pointer type that points to a defined type.<br>
	 * * The created type will exist in the context that its pointee type<br>
	 * exists in.<br>
	 * * @see llvm::PointerType::get()<br>
	 * Original signature : <code>LLVMTypeRef LLVMPointerType(LLVMTypeRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMPointerType(LLVMLibrary.LLVMTypeRef ElementType, int AddressSpace) {
		return new LLVMLibrary.LLVMTypeRef(LLVMPointerType(Pointer.getPeer(ElementType), AddressSpace));
	}
	@Ptr 
	protected native static long LLVMPointerType(@Ptr long ElementType, int AddressSpace);
	/**
	 * Obtain the address space of a pointer type.<br>
	 * * This only works on types that represent pointers.<br>
	 * * @see llvm::PointerType::getAddressSpace()<br>
	 * Original signature : <code>int LLVMGetPointerAddressSpace(LLVMTypeRef)</code>
	 */
	public static int LLVMGetPointerAddressSpace(LLVMLibrary.LLVMTypeRef PointerTy) {
		return LLVMGetPointerAddressSpace(Pointer.getPeer(PointerTy));
	}
	protected native static int LLVMGetPointerAddressSpace(@Ptr long PointerTy);
	/**
	 * Create a vector type that contains a defined type and has a specific<br>
	 * number of elements.<br>
	 * * The created type will exist in the context thats its element type<br>
	 * exists in.<br>
	 * * @see llvm::VectorType::get()<br>
	 * Original signature : <code>LLVMTypeRef LLVMVectorType(LLVMTypeRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMVectorType(LLVMLibrary.LLVMTypeRef ElementType, int ElementCount) {
		return new LLVMLibrary.LLVMTypeRef(LLVMVectorType(Pointer.getPeer(ElementType), ElementCount));
	}
	@Ptr 
	protected native static long LLVMVectorType(@Ptr long ElementType, int ElementCount);
	/**
	 * Obtain the number of elements in a vector type.<br>
	 * * This only works on types that represent vectors.<br>
	 * * @see llvm::VectorType::getNumElements()<br>
	 * Original signature : <code>int LLVMGetVectorSize(LLVMTypeRef)</code>
	 */
	public static int LLVMGetVectorSize(LLVMLibrary.LLVMTypeRef VectorTy) {
		return LLVMGetVectorSize(Pointer.getPeer(VectorTy));
	}
	protected native static int LLVMGetVectorSize(@Ptr long VectorTy);
	/**
	 * Create a void type in a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMVoidTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMVoidTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMVoidTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMVoidTypeInContext(@Ptr long C);
	/**
	 * Create a label type in a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMLabelTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMLabelTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMLabelTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMLabelTypeInContext(@Ptr long C);
	/**
	 * Create a X86 MMX type in a context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMX86MMXTypeInContext(LLVMContextRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMX86MMXTypeInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMTypeRef(LLVMX86MMXTypeInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMX86MMXTypeInContext(@Ptr long C);
	/**
	 * These are similar to the above functions except they operate on the<br>
	 * global context.<br>
	 * Original signature : <code>LLVMTypeRef LLVMVoidType()</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMVoidType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMVoidType$2());
	}
	@Ptr 
	@Name("LLVMVoidType") 
	protected native static long LLVMVoidType$2();
	/// Original signature : <code>LLVMTypeRef LLVMLabelType()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMLabelType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMLabelType$2());
	}
	@Ptr 
	@Name("LLVMLabelType") 
	protected native static long LLVMLabelType$2();
	/// Original signature : <code>LLVMTypeRef LLVMX86MMXType()</code>
	public static LLVMLibrary.LLVMTypeRef LLVMX86MMXType() {
		return new LLVMLibrary.LLVMTypeRef(LLVMX86MMXType$2());
	}
	@Ptr 
	@Name("LLVMX86MMXType") 
	protected native static long LLVMX86MMXType$2();
	/**
	 * Obtain the type of a value.<br>
	 * * @see llvm::Value::getType()<br>
	 * Original signature : <code>LLVMTypeRef LLVMTypeOf(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMTypeRef LLVMTypeOf(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMTypeRef(LLVMTypeOf(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMTypeOf(@Ptr long Val);
	/**
	 * Obtain the string name of a value.<br>
	 * * @see llvm::Value::getName()<br>
	 * Original signature : <code>char* LLVMGetValueName(LLVMValueRef)</code>
	 */
	public static Pointer<Byte > LLVMGetValueName(LLVMLibrary.LLVMValueRef Val) {
		return Pointer.pointerToAddress(LLVMGetValueName(Pointer.getPeer(Val)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetValueName(@Ptr long Val);
	/**
	 * Set the string name of a value.<br>
	 * * @see llvm::Value::setName()<br>
	 * Original signature : <code>void LLVMSetValueName(LLVMValueRef, const char*)</code>
	 */
	public static void LLVMSetValueName(LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		LLVMSetValueName(Pointer.getPeer(Val), Pointer.getPeer(Name));
	}
	protected native static void LLVMSetValueName(@Ptr long Val, @Ptr long Name);
	/**
	 * Dump a representation of a value to stderr.<br>
	 * * @see llvm::Value::dump()<br>
	 * Original signature : <code>void LLVMDumpValue(LLVMValueRef)</code>
	 */
	public static void LLVMDumpValue(LLVMLibrary.LLVMValueRef Val) {
		LLVMDumpValue(Pointer.getPeer(Val));
	}
	protected native static void LLVMDumpValue(@Ptr long Val);
	/**
	 * Replace all uses of a value with another one.<br>
	 * * @see llvm::Value::replaceAllUsesWith()<br>
	 * Original signature : <code>void LLVMReplaceAllUsesWith(LLVMValueRef, LLVMValueRef)</code>
	 */
	public static void LLVMReplaceAllUsesWith(LLVMLibrary.LLVMValueRef OldVal, LLVMLibrary.LLVMValueRef NewVal) {
		LLVMReplaceAllUsesWith(Pointer.getPeer(OldVal), Pointer.getPeer(NewVal));
	}
	protected native static void LLVMReplaceAllUsesWith(@Ptr long OldVal, @Ptr long NewVal);
	/**
	 * Determine whether the specified constant instance is constant.<br>
	 * Original signature : <code>LLVMBool LLVMIsConstant(LLVMValueRef)</code>
	 */
	public static int LLVMIsConstant(LLVMLibrary.LLVMValueRef Val) {
		return LLVMIsConstant(Pointer.getPeer(Val));
	}
	protected native static int LLVMIsConstant(@Ptr long Val);
	/**
	 * Determine whether a value instance is undefined.<br>
	 * Original signature : <code>LLVMBool LLVMIsUndef(LLVMValueRef)</code>
	 */
	public static int LLVMIsUndef(LLVMLibrary.LLVMValueRef Val) {
		return LLVMIsUndef(Pointer.getPeer(Val));
	}
	protected native static int LLVMIsUndef(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAArgument(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAArgument(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAArgument(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAArgument(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsABasicBlock(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsABasicBlock(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABasicBlock(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABasicBlock(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAInlineAsm(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAInlineAsm(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInlineAsm(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInlineAsm(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAMDNode(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAMDNode(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMDNode(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMDNode(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAMDString(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAMDString(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMDString(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMDString(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAUser(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAUser(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUser(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUser(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAConstant(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstant(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstant(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstant(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsABlockAddress(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsABlockAddress(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABlockAddress(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABlockAddress(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAConstantAggregateZero(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantAggregateZero(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantAggregateZero(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantAggregateZero(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAConstantArray(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantArray(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantArray(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantArray(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAConstantExpr(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantExpr(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantExpr(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantExpr(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAConstantFP(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantFP(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantFP(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantFP(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAConstantInt(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantInt(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantInt(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantInt(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAConstantPointerNull(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantPointerNull(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantPointerNull(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantPointerNull(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAConstantStruct(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantStruct(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantStruct(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantStruct(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAConstantVector(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAConstantVector(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAConstantVector(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAConstantVector(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAGlobalValue(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAGlobalValue(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAGlobalValue(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAGlobalValue(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAFunction(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAFunction(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFunction(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFunction(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAGlobalAlias(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAGlobalAlias(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAGlobalAlias(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAGlobalAlias(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAGlobalVariable(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAGlobalVariable(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAGlobalVariable(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAGlobalVariable(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAUndefValue(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAUndefValue(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUndefValue(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUndefValue(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAInstruction(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAInstruction(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInstruction(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInstruction(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsABinaryOperator(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsABinaryOperator(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABinaryOperator(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABinaryOperator(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsACallInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsACallInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACallInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACallInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAIntrinsicInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAIntrinsicInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAIntrinsicInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAIntrinsicInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsADbgInfoIntrinsic(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsADbgInfoIntrinsic(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsADbgInfoIntrinsic(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsADbgInfoIntrinsic(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsADbgDeclareInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsADbgDeclareInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsADbgDeclareInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsADbgDeclareInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAMemIntrinsic(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAMemIntrinsic(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMemIntrinsic(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMemIntrinsic(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAMemCpyInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAMemCpyInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMemCpyInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMemCpyInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAMemMoveInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAMemMoveInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMemMoveInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMemMoveInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAMemSetInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAMemSetInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAMemSetInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAMemSetInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsACmpInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsACmpInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACmpInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACmpInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAFCmpInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAFCmpInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFCmpInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFCmpInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAICmpInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAICmpInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAICmpInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAICmpInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAExtractElementInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAExtractElementInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAExtractElementInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAExtractElementInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAGetElementPtrInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAGetElementPtrInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAGetElementPtrInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAGetElementPtrInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAInsertElementInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAInsertElementInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInsertElementInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInsertElementInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAInsertValueInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAInsertValueInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInsertValueInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInsertValueInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsALandingPadInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsALandingPadInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsALandingPadInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsALandingPadInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAPHINode(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAPHINode(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAPHINode(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAPHINode(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsASelectInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsASelectInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsASelectInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsASelectInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAShuffleVectorInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAShuffleVectorInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAShuffleVectorInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAShuffleVectorInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAStoreInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAStoreInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAStoreInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAStoreInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsATerminatorInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsATerminatorInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsATerminatorInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsATerminatorInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsABranchInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsABranchInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABranchInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABranchInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAIndirectBrInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAIndirectBrInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAIndirectBrInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAIndirectBrInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAInvokeInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAInvokeInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAInvokeInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAInvokeInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAReturnInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAReturnInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAReturnInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAReturnInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsASwitchInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsASwitchInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsASwitchInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsASwitchInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAUnreachableInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAUnreachableInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUnreachableInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUnreachableInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAResumeInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAResumeInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAResumeInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAResumeInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAUnaryInstruction(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAUnaryInstruction(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUnaryInstruction(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUnaryInstruction(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAAllocaInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAAllocaInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAAllocaInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAAllocaInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsACastInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsACastInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsACastInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsACastInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsABitCastInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsABitCastInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsABitCastInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsABitCastInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAFPExtInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAFPExtInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFPExtInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFPExtInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAFPToSIInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAFPToSIInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFPToSIInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFPToSIInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAFPToUIInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAFPToUIInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFPToUIInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFPToUIInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAFPTruncInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAFPTruncInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAFPTruncInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAFPTruncInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAIntToPtrInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAIntToPtrInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAIntToPtrInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAIntToPtrInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAPtrToIntInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAPtrToIntInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAPtrToIntInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAPtrToIntInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsASExtInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsASExtInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsASExtInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsASExtInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsASIToFPInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsASIToFPInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsASIToFPInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsASIToFPInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsATruncInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsATruncInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsATruncInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsATruncInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAUIToFPInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAUIToFPInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAUIToFPInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAUIToFPInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAZExtInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAZExtInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAZExtInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAZExtInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAExtractValueInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAExtractValueInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAExtractValueInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAExtractValueInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsALoadInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsALoadInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsALoadInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsALoadInst(@Ptr long Val);
	/// Original signature : <code>LLVMValueRef LLVMIsAVAArgInst(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMIsAVAArgInst(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMValueRef(LLVMIsAVAArgInst(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMIsAVAArgInst(@Ptr long Val);
	/**
	 * Obtain the first use of a value.<br>
	 * * Uses are obtained in an iterator fashion. First, call this function<br>
	 * to obtain a reference to the first use. Then, call LLVMGetNextUse()<br>
	 * on that instance and all subsequently obtained instances until<br>
	 * LLVMGetNextUse() returns NULL.<br>
	 * * @see llvm::Value::use_begin()<br>
	 * Original signature : <code>LLVMUseRef LLVMGetFirstUse(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMUseRef LLVMGetFirstUse(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMUseRef(LLVMGetFirstUse(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMGetFirstUse(@Ptr long Val);
	/**
	 * Obtain the next use of a value.<br>
	 * * This effectively advances the iterator. It returns NULL if you are on<br>
	 * the final use and no more are available.<br>
	 * Original signature : <code>LLVMUseRef LLVMGetNextUse(LLVMUseRef)</code>
	 */
	public static LLVMLibrary.LLVMUseRef LLVMGetNextUse(LLVMLibrary.LLVMUseRef U) {
		return new LLVMLibrary.LLVMUseRef(LLVMGetNextUse(Pointer.getPeer(U)));
	}
	@Ptr 
	protected native static long LLVMGetNextUse(@Ptr long U);
	/**
	 * Obtain the user value for a user.<br>
	 * * The returned value corresponds to a llvm::User type.<br>
	 * * @see llvm::Use::getUser()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetUser(LLVMUseRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetUser(LLVMLibrary.LLVMUseRef U) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetUser(Pointer.getPeer(U)));
	}
	@Ptr 
	protected native static long LLVMGetUser(@Ptr long U);
	/**
	 * Obtain the value this use corresponds to.<br>
	 * * @see llvm::Use::get().<br>
	 * Original signature : <code>LLVMValueRef LLVMGetUsedValue(LLVMUseRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetUsedValue(LLVMLibrary.LLVMUseRef U) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetUsedValue(Pointer.getPeer(U)));
	}
	@Ptr 
	protected native static long LLVMGetUsedValue(@Ptr long U);
	/**
	 * Obtain an operand at a specific index in a llvm::User value.<br>
	 * * @see llvm::User::getOperand()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetOperand(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetOperand(LLVMLibrary.LLVMValueRef Val, int Index) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetOperand(Pointer.getPeer(Val), Index));
	}
	@Ptr 
	protected native static long LLVMGetOperand(@Ptr long Val, int Index);
	/**
	 * Set an operand at a specific index in a llvm::User value.<br>
	 * * @see llvm::User::setOperand()<br>
	 * Original signature : <code>void LLVMSetOperand(LLVMValueRef, unsigned, LLVMValueRef)</code>
	 */
	public static void LLVMSetOperand(LLVMLibrary.LLVMValueRef User, int Index, LLVMLibrary.LLVMValueRef Val) {
		LLVMSetOperand(Pointer.getPeer(User), Index, Pointer.getPeer(Val));
	}
	protected native static void LLVMSetOperand(@Ptr long User, int Index, @Ptr long Val);
	/**
	 * Obtain the number of operands in a llvm::User value.<br>
	 * * @see llvm::User::getNumOperands()<br>
	 * Original signature : <code>int LLVMGetNumOperands(LLVMValueRef)</code>
	 */
	public static int LLVMGetNumOperands(LLVMLibrary.LLVMValueRef Val) {
		return LLVMGetNumOperands(Pointer.getPeer(Val));
	}
	protected native static int LLVMGetNumOperands(@Ptr long Val);
	/**
	 * Obtain a constant value referring to the null instance of a type.<br>
	 * * @see llvm::Constant::getNullValue()<br>
	 * all zeroes<br>
	 * Original signature : <code>LLVMValueRef LLVMConstNull(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstNull(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNull(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMConstNull(@Ptr long Ty);
	/**
	 * Obtain a constant value referring to the instance of a type<br>
	 * consisting of all ones.<br>
	 * * This is only valid for integer types.<br>
	 * * @see llvm::Constant::getAllOnesValue()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstAllOnes(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstAllOnes(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstAllOnes(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMConstAllOnes(@Ptr long Ty);
	/**
	 * Obtain a constant value referring to an undefined value of a type.<br>
	 * * @see llvm::UndefValue::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetUndef(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetUndef(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetUndef(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMGetUndef(@Ptr long Ty);
	/**
	 * Determine whether a value instance is null.<br>
	 * * @see llvm::Constant::isNullValue()<br>
	 * Original signature : <code>LLVMBool LLVMIsNull(LLVMValueRef)</code>
	 */
	public static int LLVMIsNull(LLVMLibrary.LLVMValueRef Val) {
		return LLVMIsNull(Pointer.getPeer(Val));
	}
	protected native static int LLVMIsNull(@Ptr long Val);
	/**
	 * Obtain a constant that is a constant pointer pointing to NULL for a<br>
	 * specified type.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstPointerNull(LLVMTypeRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstPointerNull(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstPointerNull(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMConstPointerNull(@Ptr long Ty);
	/**
	 * Obtain a constant value for an integer type.<br>
	 * * The returned value corresponds to a llvm::ConstantInt.<br>
	 * * @see llvm::ConstantInt::get()<br>
	 * * @param IntTy Integer type to obtain value of.<br>
	 * @param N The value the returned instance should refer to.<br>
	 * @param SignExtend Whether to sign extend the produced value.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstInt(LLVMTypeRef, unsigned long long, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstInt(LLVMLibrary.LLVMTypeRef IntTy, long N, int SignExtend) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInt(Pointer.getPeer(IntTy), N, SignExtend));
	}
	@Ptr 
	protected native static long LLVMConstInt(@Ptr long IntTy, long N, int SignExtend);
	/**
	 * Obtain a constant value for an integer of arbitrary precision.<br>
	 * * @see llvm::ConstantInt::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstIntOfArbitraryPrecision(LLVMTypeRef, unsigned, const uint64_t[])</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstIntOfArbitraryPrecision(LLVMLibrary.LLVMTypeRef IntTy, int NumWords, Pointer<Long > Words) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntOfArbitraryPrecision(Pointer.getPeer(IntTy), NumWords, Pointer.getPeer(Words)));
	}
	@Ptr 
	protected native static long LLVMConstIntOfArbitraryPrecision(@Ptr long IntTy, int NumWords, @Ptr long Words);
	/**
	 * Obtain a constant value for an integer parsed from a string.<br>
	 * * A similar API, LLVMConstIntOfStringAndSize is also available. If the<br>
	 * string's length is available, it is preferred to call that function<br>
	 * instead.<br>
	 * * @see llvm::ConstantInt::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstIntOfString(LLVMTypeRef, const char*, uint8_t)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstIntOfString(LLVMLibrary.LLVMTypeRef IntTy, Pointer<Byte > Text, byte Radix) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntOfString(Pointer.getPeer(IntTy), Pointer.getPeer(Text), Radix));
	}
	@Ptr 
	protected native static long LLVMConstIntOfString(@Ptr long IntTy, @Ptr long Text, byte Radix);
	/**
	 * Obtain a constant value for an integer parsed from a string with<br>
	 * specified length.<br>
	 * * @see llvm::ConstantInt::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstIntOfStringAndSize(LLVMTypeRef, const char*, unsigned, uint8_t)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstIntOfStringAndSize(LLVMLibrary.LLVMTypeRef IntTy, Pointer<Byte > Text, int SLen, byte Radix) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntOfStringAndSize(Pointer.getPeer(IntTy), Pointer.getPeer(Text), SLen, Radix));
	}
	@Ptr 
	protected native static long LLVMConstIntOfStringAndSize(@Ptr long IntTy, @Ptr long Text, int SLen, byte Radix);
	/**
	 * Obtain a constant value referring to a double floating point value.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstReal(LLVMTypeRef, double)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstReal(LLVMLibrary.LLVMTypeRef RealTy, double N) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstReal(Pointer.getPeer(RealTy), N));
	}
	@Ptr 
	protected native static long LLVMConstReal(@Ptr long RealTy, double N);
	/**
	 * Obtain a constant for a floating point value parsed from a string.<br>
	 * * A similar API, LLVMConstRealOfStringAndSize is also available. It<br>
	 * should be used if the input string's length is known.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstRealOfString(LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstRealOfString(LLVMLibrary.LLVMTypeRef RealTy, Pointer<Byte > Text) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstRealOfString(Pointer.getPeer(RealTy), Pointer.getPeer(Text)));
	}
	@Ptr 
	protected native static long LLVMConstRealOfString(@Ptr long RealTy, @Ptr long Text);
	/**
	 * Obtain a constant for a floating point value parsed from a string.<br>
	 * Original signature : <code>LLVMValueRef LLVMConstRealOfStringAndSize(LLVMTypeRef, const char*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstRealOfStringAndSize(LLVMLibrary.LLVMTypeRef RealTy, Pointer<Byte > Text, int SLen) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstRealOfStringAndSize(Pointer.getPeer(RealTy), Pointer.getPeer(Text), SLen));
	}
	@Ptr 
	protected native static long LLVMConstRealOfStringAndSize(@Ptr long RealTy, @Ptr long Text, int SLen);
	/**
	 * Obtain the zero extended value for an integer constant value.<br>
	 * * @see llvm::ConstantInt::getZExtValue()<br>
	 * Original signature : <code>long long LLVMConstIntGetZExtValue(LLVMValueRef)</code>
	 */
	public static long LLVMConstIntGetZExtValue(LLVMLibrary.LLVMValueRef ConstantVal) {
		return LLVMConstIntGetZExtValue(Pointer.getPeer(ConstantVal));
	}
	protected native static long LLVMConstIntGetZExtValue(@Ptr long ConstantVal);
	/**
	 * Obtain the sign extended value for an integer constant value.<br>
	 * * @see llvm::ConstantInt::getSExtValue()<br>
	 * Original signature : <code>long long LLVMConstIntGetSExtValue(LLVMValueRef)</code>
	 */
	public static long LLVMConstIntGetSExtValue(LLVMLibrary.LLVMValueRef ConstantVal) {
		return LLVMConstIntGetSExtValue(Pointer.getPeer(ConstantVal));
	}
	protected native static long LLVMConstIntGetSExtValue(@Ptr long ConstantVal);
	/**
	 * Create a ConstantDataSequential and initialize it with a string.<br>
	 * * @see llvm::ConstantDataArray::getString()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstStringInContext(LLVMContextRef, const char*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstStringInContext(LLVMLibrary.LLVMContextRef C, Pointer<Byte > Str, int Length, int DontNullTerminate) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstStringInContext(Pointer.getPeer(C), Pointer.getPeer(Str), Length, DontNullTerminate));
	}
	@Ptr 
	protected native static long LLVMConstStringInContext(@Ptr long C, @Ptr long Str, int Length, int DontNullTerminate);
	/**
	 * Create a ConstantDataSequential with string content in the global context.<br>
	 * * This is the same as LLVMConstStringInContext except it operates on the<br>
	 * global context.<br>
	 * * @see LLVMConstStringInContext()<br>
	 * @see llvm::ConstantDataArray::getString()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstString(const char*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstString(Pointer<Byte > Str, int Length, int DontNullTerminate) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstString(Pointer.getPeer(Str), Length, DontNullTerminate));
	}
	@Ptr 
	protected native static long LLVMConstString(@Ptr long Str, int Length, int DontNullTerminate);
	/**
	 * Create an anonymous ConstantStruct with the specified values.<br>
	 * * @see llvm::ConstantStruct::getAnon()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstStructInContext(LLVMContextRef, LLVMValueRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstStructInContext(LLVMLibrary.LLVMContextRef C, Pointer<LLVMLibrary.LLVMValueRef > ConstantVals, int Count, int Packed) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstStructInContext(Pointer.getPeer(C), Pointer.getPeer(ConstantVals), Count, Packed));
	}
	@Ptr 
	protected native static long LLVMConstStructInContext(@Ptr long C, @Ptr long ConstantVals, int Count, int Packed);
	/**
	 * Create a ConstantStruct in the global Context.<br>
	 * * This is the same as LLVMConstStructInContext except it operates on the<br>
	 * global Context.<br>
	 * * @see LLVMConstStructInContext()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstStruct(LLVMValueRef*, unsigned, LLVMBool)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstStruct(Pointer<LLVMLibrary.LLVMValueRef > ConstantVals, int Count, int Packed) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstStruct(Pointer.getPeer(ConstantVals), Count, Packed));
	}
	@Ptr 
	protected native static long LLVMConstStruct(@Ptr long ConstantVals, int Count, int Packed);
	/**
	 * Create a ConstantArray from values.<br>
	 * * @see llvm::ConstantArray::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstArray(LLVMTypeRef, LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstArray(LLVMLibrary.LLVMTypeRef ElementTy, Pointer<LLVMLibrary.LLVMValueRef > ConstantVals, int Length) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstArray(Pointer.getPeer(ElementTy), Pointer.getPeer(ConstantVals), Length));
	}
	@Ptr 
	protected native static long LLVMConstArray(@Ptr long ElementTy, @Ptr long ConstantVals, int Length);
	/**
	 * Create a non-anonymous ConstantStruct from values.<br>
	 * * @see llvm::ConstantStruct::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstNamedStruct(LLVMTypeRef, LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstNamedStruct(LLVMLibrary.LLVMTypeRef StructTy, Pointer<LLVMLibrary.LLVMValueRef > ConstantVals, int Count) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNamedStruct(Pointer.getPeer(StructTy), Pointer.getPeer(ConstantVals), Count));
	}
	@Ptr 
	protected native static long LLVMConstNamedStruct(@Ptr long StructTy, @Ptr long ConstantVals, int Count);
	/**
	 * Create a ConstantVector from values.<br>
	 * * @see llvm::ConstantVector::get()<br>
	 * Original signature : <code>LLVMValueRef LLVMConstVector(LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMConstVector(Pointer<LLVMLibrary.LLVMValueRef > ScalarConstantVals, int Size) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstVector(Pointer.getPeer(ScalarConstantVals), Size));
	}
	@Ptr 
	protected native static long LLVMConstVector(@Ptr long ScalarConstantVals, int Size);
	/**
	 * @defgroup LLVMCCoreValueConstantExpressions Constant Expressions<br>
	 * * Functions in this group correspond to APIs on llvm::ConstantExpr.<br>
	 * * @see llvm::ConstantExpr.<br>
	 * * @{<br>
	 * Original signature : <code>LLVMOpcode LLVMGetConstOpcode(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMOpcode > LLVMGetConstOpcode(LLVMLibrary.LLVMValueRef ConstantVal) {
		return FlagSet.fromValue(LLVMGetConstOpcode(Pointer.getPeer(ConstantVal)), LLVMLibrary.LLVMOpcode.class);
	}
	protected native static int LLVMGetConstOpcode(@Ptr long ConstantVal);
	/// Original signature : <code>LLVMValueRef LLVMAlignOf(LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMAlignOf(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMAlignOf(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMAlignOf(@Ptr long Ty);
	/// Original signature : <code>LLVMValueRef LLVMSizeOf(LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMSizeOf(LLVMLibrary.LLVMTypeRef Ty) {
		return new LLVMLibrary.LLVMValueRef(LLVMSizeOf(Pointer.getPeer(Ty)));
	}
	@Ptr 
	protected native static long LLVMSizeOf(@Ptr long Ty);
	/// Original signature : <code>LLVMValueRef LLVMConstNeg(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNeg(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNeg(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstNeg(@Ptr long ConstantVal);
	/// Original signature : <code>LLVMValueRef LLVMConstNSWNeg(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNSWNeg(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNSWNeg(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstNSWNeg(@Ptr long ConstantVal);
	/// Original signature : <code>LLVMValueRef LLVMConstNUWNeg(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNUWNeg(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNUWNeg(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstNUWNeg(@Ptr long ConstantVal);
	/// Original signature : <code>LLVMValueRef LLVMConstFNeg(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFNeg(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFNeg(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstFNeg(@Ptr long ConstantVal);
	/// Original signature : <code>LLVMValueRef LLVMConstNot(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNot(LLVMLibrary.LLVMValueRef ConstantVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNot(Pointer.getPeer(ConstantVal)));
	}
	@Ptr 
	protected native static long LLVMConstNot(@Ptr long ConstantVal);
	/// Original signature : <code>LLVMValueRef LLVMConstAdd(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstAdd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstAdd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstAdd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstNSWAdd(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNSWAdd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNSWAdd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNSWAdd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstNUWAdd(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNUWAdd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNUWAdd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNUWAdd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstFAdd(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFAdd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFAdd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFAdd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstSub(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstSub(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSub(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstSub(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstNSWSub(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNSWSub(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNSWSub(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNSWSub(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstNUWSub(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNUWSub(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNUWSub(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNUWSub(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstFSub(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFSub(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFSub(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFSub(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstMul(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstMul(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstMul(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstMul(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstNSWMul(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNSWMul(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNSWMul(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNSWMul(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstNUWMul(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstNUWMul(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstNUWMul(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstNUWMul(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstFMul(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFMul(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFMul(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFMul(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstUDiv(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstUDiv(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstUDiv(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstUDiv(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstSDiv(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstSDiv(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSDiv(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstSDiv(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstExactSDiv(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstExactSDiv(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstExactSDiv(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstExactSDiv(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstFDiv(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFDiv(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFDiv(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFDiv(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstURem(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstURem(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstURem(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstURem(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstSRem(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstSRem(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSRem(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstSRem(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstFRem(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFRem(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFRem(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFRem(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstAnd(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstAnd(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstAnd(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstAnd(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstOr(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstOr(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstOr(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstOr(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstXor(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstXor(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstXor(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstXor(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstICmp(LLVMIntPredicate, LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstICmp(IntValuedEnum<LLVMLibrary.LLVMIntPredicate > Predicate, LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstICmp((int)Predicate.value(), Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstICmp(int Predicate, @Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstFCmp(LLVMRealPredicate, LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFCmp(IntValuedEnum<LLVMLibrary.LLVMRealPredicate > Predicate, LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFCmp((int)Predicate.value(), Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstFCmp(int Predicate, @Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstShl(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstShl(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstShl(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstShl(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstLShr(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstLShr(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstLShr(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstLShr(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstAShr(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstAShr(LLVMLibrary.LLVMValueRef LHSConstant, LLVMLibrary.LLVMValueRef RHSConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstAShr(Pointer.getPeer(LHSConstant), Pointer.getPeer(RHSConstant)));
	}
	@Ptr 
	protected native static long LLVMConstAShr(@Ptr long LHSConstant, @Ptr long RHSConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstGEP(LLVMValueRef, LLVMValueRef*, unsigned)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstGEP(LLVMLibrary.LLVMValueRef ConstantVal, Pointer<LLVMLibrary.LLVMValueRef > ConstantIndices, int NumIndices) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstGEP(Pointer.getPeer(ConstantVal), Pointer.getPeer(ConstantIndices), NumIndices));
	}
	@Ptr 
	protected native static long LLVMConstGEP(@Ptr long ConstantVal, @Ptr long ConstantIndices, int NumIndices);
	/// Original signature : <code>LLVMValueRef LLVMConstInBoundsGEP(LLVMValueRef, LLVMValueRef*, unsigned)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstInBoundsGEP(LLVMLibrary.LLVMValueRef ConstantVal, Pointer<LLVMLibrary.LLVMValueRef > ConstantIndices, int NumIndices) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInBoundsGEP(Pointer.getPeer(ConstantVal), Pointer.getPeer(ConstantIndices), NumIndices));
	}
	@Ptr 
	protected native static long LLVMConstInBoundsGEP(@Ptr long ConstantVal, @Ptr long ConstantIndices, int NumIndices);
	/// Original signature : <code>LLVMValueRef LLVMConstTrunc(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstTrunc(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstTrunc(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstTrunc(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstSExt(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstSExt(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSExt(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstSExt(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstZExt(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstZExt(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstZExt(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstZExt(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstFPTrunc(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFPTrunc(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPTrunc(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPTrunc(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstFPExt(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFPExt(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPExt(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPExt(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstUIToFP(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstUIToFP(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstUIToFP(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstUIToFP(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstSIToFP(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstSIToFP(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSIToFP(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstSIToFP(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstFPToUI(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFPToUI(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPToUI(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPToUI(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstFPToSI(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFPToSI(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPToSI(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPToSI(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstPtrToInt(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstPtrToInt(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstPtrToInt(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstPtrToInt(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstIntToPtr(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstIntToPtr(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntToPtr(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstIntToPtr(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstBitCast(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstBitCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstBitCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstBitCast(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstZExtOrBitCast(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstZExtOrBitCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstZExtOrBitCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstZExtOrBitCast(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstSExtOrBitCast(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstSExtOrBitCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSExtOrBitCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstSExtOrBitCast(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstTruncOrBitCast(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstTruncOrBitCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstTruncOrBitCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstTruncOrBitCast(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstPointerCast(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstPointerCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstPointerCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstPointerCast(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstIntCast(LLVMValueRef, LLVMTypeRef, LLVMBool)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstIntCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType, int isSigned) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstIntCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType), isSigned));
	}
	@Ptr 
	protected native static long LLVMConstIntCast(@Ptr long ConstantVal, @Ptr long ToType, int isSigned);
	/// Original signature : <code>LLVMValueRef LLVMConstFPCast(LLVMValueRef, LLVMTypeRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstFPCast(LLVMLibrary.LLVMValueRef ConstantVal, LLVMLibrary.LLVMTypeRef ToType) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstFPCast(Pointer.getPeer(ConstantVal), Pointer.getPeer(ToType)));
	}
	@Ptr 
	protected native static long LLVMConstFPCast(@Ptr long ConstantVal, @Ptr long ToType);
	/// Original signature : <code>LLVMValueRef LLVMConstSelect(LLVMValueRef, LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstSelect(LLVMLibrary.LLVMValueRef ConstantCondition, LLVMLibrary.LLVMValueRef ConstantIfTrue, LLVMLibrary.LLVMValueRef ConstantIfFalse) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstSelect(Pointer.getPeer(ConstantCondition), Pointer.getPeer(ConstantIfTrue), Pointer.getPeer(ConstantIfFalse)));
	}
	@Ptr 
	protected native static long LLVMConstSelect(@Ptr long ConstantCondition, @Ptr long ConstantIfTrue, @Ptr long ConstantIfFalse);
	/// Original signature : <code>LLVMValueRef LLVMConstExtractElement(LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstExtractElement(LLVMLibrary.LLVMValueRef VectorConstant, LLVMLibrary.LLVMValueRef IndexConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstExtractElement(Pointer.getPeer(VectorConstant), Pointer.getPeer(IndexConstant)));
	}
	@Ptr 
	protected native static long LLVMConstExtractElement(@Ptr long VectorConstant, @Ptr long IndexConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstInsertElement(LLVMValueRef, LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstInsertElement(LLVMLibrary.LLVMValueRef VectorConstant, LLVMLibrary.LLVMValueRef ElementValueConstant, LLVMLibrary.LLVMValueRef IndexConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInsertElement(Pointer.getPeer(VectorConstant), Pointer.getPeer(ElementValueConstant), Pointer.getPeer(IndexConstant)));
	}
	@Ptr 
	protected native static long LLVMConstInsertElement(@Ptr long VectorConstant, @Ptr long ElementValueConstant, @Ptr long IndexConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstShuffleVector(LLVMValueRef, LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstShuffleVector(LLVMLibrary.LLVMValueRef VectorAConstant, LLVMLibrary.LLVMValueRef VectorBConstant, LLVMLibrary.LLVMValueRef MaskConstant) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstShuffleVector(Pointer.getPeer(VectorAConstant), Pointer.getPeer(VectorBConstant), Pointer.getPeer(MaskConstant)));
	}
	@Ptr 
	protected native static long LLVMConstShuffleVector(@Ptr long VectorAConstant, @Ptr long VectorBConstant, @Ptr long MaskConstant);
	/// Original signature : <code>LLVMValueRef LLVMConstExtractValue(LLVMValueRef, unsigned*, unsigned)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstExtractValue(LLVMLibrary.LLVMValueRef AggConstant, Pointer<Integer > IdxList, int NumIdx) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstExtractValue(Pointer.getPeer(AggConstant), Pointer.getPeer(IdxList), NumIdx));
	}
	@Ptr 
	protected native static long LLVMConstExtractValue(@Ptr long AggConstant, @Ptr long IdxList, int NumIdx);
	/// Original signature : <code>LLVMValueRef LLVMConstInsertValue(LLVMValueRef, LLVMValueRef, unsigned*, unsigned)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstInsertValue(LLVMLibrary.LLVMValueRef AggConstant, LLVMLibrary.LLVMValueRef ElementValueConstant, Pointer<Integer > IdxList, int NumIdx) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInsertValue(Pointer.getPeer(AggConstant), Pointer.getPeer(ElementValueConstant), Pointer.getPeer(IdxList), NumIdx));
	}
	@Ptr 
	protected native static long LLVMConstInsertValue(@Ptr long AggConstant, @Ptr long ElementValueConstant, @Ptr long IdxList, int NumIdx);
	/// Original signature : <code>LLVMValueRef LLVMConstInlineAsm(LLVMTypeRef, const char*, const char*, LLVMBool, LLVMBool)</code>
	public static LLVMLibrary.LLVMValueRef LLVMConstInlineAsm(LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > AsmString, Pointer<Byte > Constraints, int HasSideEffects, int IsAlignStack) {
		return new LLVMLibrary.LLVMValueRef(LLVMConstInlineAsm(Pointer.getPeer(Ty), Pointer.getPeer(AsmString), Pointer.getPeer(Constraints), HasSideEffects, IsAlignStack));
	}
	@Ptr 
	protected native static long LLVMConstInlineAsm(@Ptr long Ty, @Ptr long AsmString, @Ptr long Constraints, int HasSideEffects, int IsAlignStack);
	/// Original signature : <code>LLVMValueRef LLVMBlockAddress(LLVMValueRef, LLVMBasicBlockRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBlockAddress(LLVMLibrary.LLVMValueRef F, LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMBlockAddress(Pointer.getPeer(F), Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMBlockAddress(@Ptr long F, @Ptr long BB);
	/// Original signature : <code>LLVMModuleRef LLVMGetGlobalParent(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMModuleRef LLVMGetGlobalParent(LLVMLibrary.LLVMValueRef Global) {
		return new LLVMLibrary.LLVMModuleRef(LLVMGetGlobalParent(Pointer.getPeer(Global)));
	}
	@Ptr 
	protected native static long LLVMGetGlobalParent(@Ptr long Global);
	/// Original signature : <code>LLVMBool LLVMIsDeclaration(LLVMValueRef)</code>
	public static int LLVMIsDeclaration(LLVMLibrary.LLVMValueRef Global) {
		return LLVMIsDeclaration(Pointer.getPeer(Global));
	}
	protected native static int LLVMIsDeclaration(@Ptr long Global);
	/// Original signature : <code>LLVMLinkage LLVMGetLinkage(LLVMValueRef)</code>
	public static IntValuedEnum<LLVMLibrary.LLVMLinkage > LLVMGetLinkage(LLVMLibrary.LLVMValueRef Global) {
		return FlagSet.fromValue(LLVMGetLinkage(Pointer.getPeer(Global)), LLVMLibrary.LLVMLinkage.class);
	}
	protected native static int LLVMGetLinkage(@Ptr long Global);
	/// Original signature : <code>void LLVMSetLinkage(LLVMValueRef, LLVMLinkage)</code>
	public static void LLVMSetLinkage(LLVMLibrary.LLVMValueRef Global, IntValuedEnum<LLVMLibrary.LLVMLinkage > Linkage) {
		LLVMSetLinkage(Pointer.getPeer(Global), (int)Linkage.value());
	}
	protected native static void LLVMSetLinkage(@Ptr long Global, int Linkage);
	/// Original signature : <code>char* LLVMGetSection(LLVMValueRef)</code>
	public static Pointer<Byte > LLVMGetSection(LLVMLibrary.LLVMValueRef Global) {
		return Pointer.pointerToAddress(LLVMGetSection(Pointer.getPeer(Global)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetSection(@Ptr long Global);
	/// Original signature : <code>void LLVMSetSection(LLVMValueRef, const char*)</code>
	public static void LLVMSetSection(LLVMLibrary.LLVMValueRef Global, Pointer<Byte > Section) {
		LLVMSetSection(Pointer.getPeer(Global), Pointer.getPeer(Section));
	}
	protected native static void LLVMSetSection(@Ptr long Global, @Ptr long Section);
	/// Original signature : <code>LLVMVisibility LLVMGetVisibility(LLVMValueRef)</code>
	public static IntValuedEnum<LLVMLibrary.LLVMVisibility > LLVMGetVisibility(LLVMLibrary.LLVMValueRef Global) {
		return FlagSet.fromValue(LLVMGetVisibility(Pointer.getPeer(Global)), LLVMLibrary.LLVMVisibility.class);
	}
	protected native static int LLVMGetVisibility(@Ptr long Global);
	/// Original signature : <code>void LLVMSetVisibility(LLVMValueRef, LLVMVisibility)</code>
	public static void LLVMSetVisibility(LLVMLibrary.LLVMValueRef Global, IntValuedEnum<LLVMLibrary.LLVMVisibility > Viz) {
		LLVMSetVisibility(Pointer.getPeer(Global), (int)Viz.value());
	}
	protected native static void LLVMSetVisibility(@Ptr long Global, int Viz);
	/// Original signature : <code>int LLVMGetAlignment(LLVMValueRef)</code>
	public static int LLVMGetAlignment(LLVMLibrary.LLVMValueRef Global) {
		return LLVMGetAlignment(Pointer.getPeer(Global));
	}
	protected native static int LLVMGetAlignment(@Ptr long Global);
	/// Original signature : <code>void LLVMSetAlignment(LLVMValueRef, unsigned)</code>
	public static void LLVMSetAlignment(LLVMLibrary.LLVMValueRef Global, int Bytes) {
		LLVMSetAlignment(Pointer.getPeer(Global), Bytes);
	}
	protected native static void LLVMSetAlignment(@Ptr long Global, int Bytes);
	/**
	 * @defgroup LLVMCoreValueConstantGlobalVariable Global Variables<br>
	 * * This group contains functions that operate on global variable values.<br>
	 * * @see llvm::GlobalVariable<br>
	 * * @{<br>
	 * Original signature : <code>LLVMValueRef LLVMAddGlobal(LLVMModuleRef, LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMAddGlobal(LLVMLibrary.LLVMModuleRef M, LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMAddGlobal(Pointer.getPeer(M), Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMAddGlobal(@Ptr long M, @Ptr long Ty, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMAddGlobalInAddressSpace(LLVMModuleRef, LLVMTypeRef, const char*, unsigned)</code>
	public static LLVMLibrary.LLVMValueRef LLVMAddGlobalInAddressSpace(LLVMLibrary.LLVMModuleRef M, LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name, int AddressSpace) {
		return new LLVMLibrary.LLVMValueRef(LLVMAddGlobalInAddressSpace(Pointer.getPeer(M), Pointer.getPeer(Ty), Pointer.getPeer(Name), AddressSpace));
	}
	@Ptr 
	protected native static long LLVMAddGlobalInAddressSpace(@Ptr long M, @Ptr long Ty, @Ptr long Name, int AddressSpace);
	/// Original signature : <code>LLVMValueRef LLVMGetNamedGlobal(LLVMModuleRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMGetNamedGlobal(LLVMLibrary.LLVMModuleRef M, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNamedGlobal(Pointer.getPeer(M), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMGetNamedGlobal(@Ptr long M, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMGetFirstGlobal(LLVMModuleRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMGetFirstGlobal(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetFirstGlobal(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetFirstGlobal(@Ptr long M);
	/// Original signature : <code>LLVMValueRef LLVMGetLastGlobal(LLVMModuleRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMGetLastGlobal(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetLastGlobal(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMGetLastGlobal(@Ptr long M);
	/// Original signature : <code>LLVMValueRef LLVMGetNextGlobal(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMGetNextGlobal(LLVMLibrary.LLVMValueRef GlobalVar) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNextGlobal(Pointer.getPeer(GlobalVar)));
	}
	@Ptr 
	protected native static long LLVMGetNextGlobal(@Ptr long GlobalVar);
	/// Original signature : <code>LLVMValueRef LLVMGetPreviousGlobal(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMGetPreviousGlobal(LLVMLibrary.LLVMValueRef GlobalVar) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetPreviousGlobal(Pointer.getPeer(GlobalVar)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousGlobal(@Ptr long GlobalVar);
	/// Original signature : <code>void LLVMDeleteGlobal(LLVMValueRef)</code>
	public static void LLVMDeleteGlobal(LLVMLibrary.LLVMValueRef GlobalVar) {
		LLVMDeleteGlobal(Pointer.getPeer(GlobalVar));
	}
	protected native static void LLVMDeleteGlobal(@Ptr long GlobalVar);
	/// Original signature : <code>LLVMValueRef LLVMGetInitializer(LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMGetInitializer(LLVMLibrary.LLVMValueRef GlobalVar) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetInitializer(Pointer.getPeer(GlobalVar)));
	}
	@Ptr 
	protected native static long LLVMGetInitializer(@Ptr long GlobalVar);
	/// Original signature : <code>void LLVMSetInitializer(LLVMValueRef, LLVMValueRef)</code>
	public static void LLVMSetInitializer(LLVMLibrary.LLVMValueRef GlobalVar, LLVMLibrary.LLVMValueRef ConstantVal) {
		LLVMSetInitializer(Pointer.getPeer(GlobalVar), Pointer.getPeer(ConstantVal));
	}
	protected native static void LLVMSetInitializer(@Ptr long GlobalVar, @Ptr long ConstantVal);
	/// Original signature : <code>LLVMBool LLVMIsThreadLocal(LLVMValueRef)</code>
	public static int LLVMIsThreadLocal(LLVMLibrary.LLVMValueRef GlobalVar) {
		return LLVMIsThreadLocal(Pointer.getPeer(GlobalVar));
	}
	protected native static int LLVMIsThreadLocal(@Ptr long GlobalVar);
	/// Original signature : <code>void LLVMSetThreadLocal(LLVMValueRef, LLVMBool)</code>
	public static void LLVMSetThreadLocal(LLVMLibrary.LLVMValueRef GlobalVar, int IsThreadLocal) {
		LLVMSetThreadLocal(Pointer.getPeer(GlobalVar), IsThreadLocal);
	}
	protected native static void LLVMSetThreadLocal(@Ptr long GlobalVar, int IsThreadLocal);
	/// Original signature : <code>LLVMBool LLVMIsGlobalConstant(LLVMValueRef)</code>
	public static int LLVMIsGlobalConstant(LLVMLibrary.LLVMValueRef GlobalVar) {
		return LLVMIsGlobalConstant(Pointer.getPeer(GlobalVar));
	}
	protected native static int LLVMIsGlobalConstant(@Ptr long GlobalVar);
	/// Original signature : <code>void LLVMSetGlobalConstant(LLVMValueRef, LLVMBool)</code>
	public static void LLVMSetGlobalConstant(LLVMLibrary.LLVMValueRef GlobalVar, int IsConstant) {
		LLVMSetGlobalConstant(Pointer.getPeer(GlobalVar), IsConstant);
	}
	protected native static void LLVMSetGlobalConstant(@Ptr long GlobalVar, int IsConstant);
	/// Original signature : <code>LLVMThreadLocalMode LLVMGetThreadLocalMode(LLVMValueRef)</code>
	public static IntValuedEnum<LLVMLibrary.LLVMThreadLocalMode > LLVMGetThreadLocalMode(LLVMLibrary.LLVMValueRef GlobalVar) {
		return FlagSet.fromValue(LLVMGetThreadLocalMode(Pointer.getPeer(GlobalVar)), LLVMLibrary.LLVMThreadLocalMode.class);
	}
	protected native static int LLVMGetThreadLocalMode(@Ptr long GlobalVar);
	/// Original signature : <code>void LLVMSetThreadLocalMode(LLVMValueRef, LLVMThreadLocalMode)</code>
	public static void LLVMSetThreadLocalMode(LLVMLibrary.LLVMValueRef GlobalVar, IntValuedEnum<LLVMLibrary.LLVMThreadLocalMode > Mode) {
		LLVMSetThreadLocalMode(Pointer.getPeer(GlobalVar), (int)Mode.value());
	}
	protected native static void LLVMSetThreadLocalMode(@Ptr long GlobalVar, int Mode);
	/// Original signature : <code>LLVMBool LLVMIsExternallyInitialized(LLVMValueRef)</code>
	public static int LLVMIsExternallyInitialized(LLVMLibrary.LLVMValueRef GlobalVar) {
		return LLVMIsExternallyInitialized(Pointer.getPeer(GlobalVar));
	}
	protected native static int LLVMIsExternallyInitialized(@Ptr long GlobalVar);
	/// Original signature : <code>void LLVMSetExternallyInitialized(LLVMValueRef, LLVMBool)</code>
	public static void LLVMSetExternallyInitialized(LLVMLibrary.LLVMValueRef GlobalVar, int IsExtInit) {
		LLVMSetExternallyInitialized(Pointer.getPeer(GlobalVar), IsExtInit);
	}
	protected native static void LLVMSetExternallyInitialized(@Ptr long GlobalVar, int IsExtInit);
	/**
	 * @defgroup LLVMCoreValueConstantGlobalAlias Global Aliases<br>
	 * * This group contains function that operate on global alias values.<br>
	 * * @see llvm::GlobalAlias<br>
	 * * @{<br>
	 * Original signature : <code>LLVMValueRef LLVMAddAlias(LLVMModuleRef, LLVMTypeRef, LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMAddAlias(LLVMLibrary.LLVMModuleRef M, LLVMLibrary.LLVMTypeRef Ty, LLVMLibrary.LLVMValueRef Aliasee, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMAddAlias(Pointer.getPeer(M), Pointer.getPeer(Ty), Pointer.getPeer(Aliasee), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMAddAlias(@Ptr long M, @Ptr long Ty, @Ptr long Aliasee, @Ptr long Name);
	/**
	 * Remove a function from its containing module and deletes it.<br>
	 * * @see llvm::Function::eraseFromParent()<br>
	 * Original signature : <code>void LLVMDeleteFunction(LLVMValueRef)</code>
	 */
	public static void LLVMDeleteFunction(LLVMLibrary.LLVMValueRef Fn) {
		LLVMDeleteFunction(Pointer.getPeer(Fn));
	}
	protected native static void LLVMDeleteFunction(@Ptr long Fn);
	/**
	 * Obtain the ID number from a function instance.<br>
	 * * @see llvm::Function::getIntrinsicID()<br>
	 * Original signature : <code>int LLVMGetIntrinsicID(LLVMValueRef)</code>
	 */
	public static int LLVMGetIntrinsicID(LLVMLibrary.LLVMValueRef Fn) {
		return LLVMGetIntrinsicID(Pointer.getPeer(Fn));
	}
	protected native static int LLVMGetIntrinsicID(@Ptr long Fn);
	/**
	 * Obtain the calling function of a function.<br>
	 * * The returned value corresponds to the LLVMCallConv enumeration.<br>
	 * * @see llvm::Function::getCallingConv()<br>
	 * Original signature : <code>int LLVMGetFunctionCallConv(LLVMValueRef)</code>
	 */
	public static int LLVMGetFunctionCallConv(LLVMLibrary.LLVMValueRef Fn) {
		return LLVMGetFunctionCallConv(Pointer.getPeer(Fn));
	}
	protected native static int LLVMGetFunctionCallConv(@Ptr long Fn);
	/**
	 * Set the calling convention of a function.<br>
	 * * @see llvm::Function::setCallingConv()<br>
	 * * @param Fn Function to operate on<br>
	 * @param CC LLVMCallConv to set calling convention to<br>
	 * Original signature : <code>void LLVMSetFunctionCallConv(LLVMValueRef, unsigned)</code>
	 */
	public static void LLVMSetFunctionCallConv(LLVMLibrary.LLVMValueRef Fn, int CC) {
		LLVMSetFunctionCallConv(Pointer.getPeer(Fn), CC);
	}
	protected native static void LLVMSetFunctionCallConv(@Ptr long Fn, int CC);
	/**
	 * Obtain the name of the garbage collector to use during code<br>
	 * generation.<br>
	 * * @see llvm::Function::getGC()<br>
	 * Original signature : <code>char* LLVMGetGC(LLVMValueRef)</code>
	 */
	public static Pointer<Byte > LLVMGetGC(LLVMLibrary.LLVMValueRef Fn) {
		return Pointer.pointerToAddress(LLVMGetGC(Pointer.getPeer(Fn)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetGC(@Ptr long Fn);
	/**
	 * Define the garbage collector to use during code generation.<br>
	 * * @see llvm::Function::setGC()<br>
	 * Original signature : <code>void LLVMSetGC(LLVMValueRef, const char*)</code>
	 */
	public static void LLVMSetGC(LLVMLibrary.LLVMValueRef Fn, Pointer<Byte > Name) {
		LLVMSetGC(Pointer.getPeer(Fn), Pointer.getPeer(Name));
	}
	protected native static void LLVMSetGC(@Ptr long Fn, @Ptr long Name);
	/**
	 * Add an attribute to a function.<br>
	 * * @see llvm::Function::addAttribute()<br>
	 * Original signature : <code>void LLVMAddFunctionAttr(LLVMValueRef, LLVMAttribute)</code>
	 */
	public static void LLVMAddFunctionAttr(LLVMLibrary.LLVMValueRef Fn, IntValuedEnum<LLVMLibrary.LLVMAttribute > PA) {
		LLVMAddFunctionAttr(Pointer.getPeer(Fn), (int)PA.value());
	}
	protected native static void LLVMAddFunctionAttr(@Ptr long Fn, int PA);
	/**
	 * Add a target-dependent attribute to a fuction<br>
	 * @see llvm::AttrBuilder::addAttribute()<br>
	 * Original signature : <code>void LLVMAddTargetDependentFunctionAttr(LLVMValueRef, const char*, const char*)</code>
	 */
	public static void LLVMAddTargetDependentFunctionAttr(LLVMLibrary.LLVMValueRef Fn, Pointer<Byte > A, Pointer<Byte > V) {
		LLVMAddTargetDependentFunctionAttr(Pointer.getPeer(Fn), Pointer.getPeer(A), Pointer.getPeer(V));
	}
	protected native static void LLVMAddTargetDependentFunctionAttr(@Ptr long Fn, @Ptr long A, @Ptr long V);
	/**
	 * Obtain an attribute from a function.<br>
	 * * @see llvm::Function::getAttributes()<br>
	 * Original signature : <code>LLVMAttribute LLVMGetFunctionAttr(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMAttribute > LLVMGetFunctionAttr(LLVMLibrary.LLVMValueRef Fn) {
		return FlagSet.fromValue(LLVMGetFunctionAttr(Pointer.getPeer(Fn)), LLVMLibrary.LLVMAttribute.class);
	}
	protected native static int LLVMGetFunctionAttr(@Ptr long Fn);
	/**
	 * Remove an attribute from a function.<br>
	 * Original signature : <code>void LLVMRemoveFunctionAttr(LLVMValueRef, LLVMAttribute)</code>
	 */
	public static void LLVMRemoveFunctionAttr(LLVMLibrary.LLVMValueRef Fn, IntValuedEnum<LLVMLibrary.LLVMAttribute > PA) {
		LLVMRemoveFunctionAttr(Pointer.getPeer(Fn), (int)PA.value());
	}
	protected native static void LLVMRemoveFunctionAttr(@Ptr long Fn, int PA);
	/**
	 * Obtain the number of parameters in a function.<br>
	 * * @see llvm::Function::arg_size()<br>
	 * Original signature : <code>int LLVMCountParams(LLVMValueRef)</code>
	 */
	public static int LLVMCountParams(LLVMLibrary.LLVMValueRef Fn) {
		return LLVMCountParams(Pointer.getPeer(Fn));
	}
	protected native static int LLVMCountParams(@Ptr long Fn);
	/**
	 * Obtain the parameters in a function.<br>
	 * * The takes a pointer to a pre-allocated array of LLVMValueRef that is<br>
	 * at least LLVMCountParams() long. This array will be filled with<br>
	 * LLVMValueRef instances which correspond to the parameters the<br>
	 * function receives. Each LLVMValueRef corresponds to a llvm::Argument<br>
	 * instance.<br>
	 * * @see llvm::Function::arg_begin()<br>
	 * Original signature : <code>void LLVMGetParams(LLVMValueRef, LLVMValueRef*)</code>
	 */
	public static void LLVMGetParams(LLVMLibrary.LLVMValueRef Fn, Pointer<LLVMLibrary.LLVMValueRef > Params) {
		LLVMGetParams(Pointer.getPeer(Fn), Pointer.getPeer(Params));
	}
	protected native static void LLVMGetParams(@Ptr long Fn, @Ptr long Params);
	/**
	 * Obtain the parameter at the specified index.<br>
	 * * Parameters are indexed from 0.<br>
	 * * @see llvm::Function::arg_begin()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetParam(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetParam(LLVMLibrary.LLVMValueRef Fn, int Index) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetParam(Pointer.getPeer(Fn), Index));
	}
	@Ptr 
	protected native static long LLVMGetParam(@Ptr long Fn, int Index);
	/**
	 * Obtain the function to which this argument belongs.<br>
	 * * Unlike other functions in this group, this one takes a LLVMValueRef<br>
	 * that corresponds to a llvm::Attribute.<br>
	 * * The returned LLVMValueRef is the llvm::Function to which this<br>
	 * argument belongs.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetParamParent(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetParamParent(LLVMLibrary.LLVMValueRef Inst) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetParamParent(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMGetParamParent(@Ptr long Inst);
	/**
	 * Obtain the first parameter to a function.<br>
	 * * @see llvm::Function::arg_begin()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetFirstParam(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetFirstParam(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetFirstParam(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetFirstParam(@Ptr long Fn);
	/**
	 * Obtain the last parameter to a function.<br>
	 * * @see llvm::Function::arg_end()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetLastParam(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetLastParam(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetLastParam(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetLastParam(@Ptr long Fn);
	/**
	 * Obtain the next parameter to a function.<br>
	 * * This takes a LLVMValueRef obtained from LLVMGetFirstParam() (which is<br>
	 * actually a wrapped iterator) and obtains the next parameter from the<br>
	 * underlying iterator.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetNextParam(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetNextParam(LLVMLibrary.LLVMValueRef Arg) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNextParam(Pointer.getPeer(Arg)));
	}
	@Ptr 
	protected native static long LLVMGetNextParam(@Ptr long Arg);
	/**
	 * Obtain the previous parameter to a function.<br>
	 * * This is the opposite of LLVMGetNextParam().<br>
	 * Original signature : <code>LLVMValueRef LLVMGetPreviousParam(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetPreviousParam(LLVMLibrary.LLVMValueRef Arg) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetPreviousParam(Pointer.getPeer(Arg)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousParam(@Ptr long Arg);
	/**
	 * Add an attribute to a function argument.<br>
	 * * @see llvm::Argument::addAttr()<br>
	 * Original signature : <code>void LLVMAddAttribute(LLVMValueRef, LLVMAttribute)</code>
	 */
	public static void LLVMAddAttribute(LLVMLibrary.LLVMValueRef Arg, IntValuedEnum<LLVMLibrary.LLVMAttribute > PA) {
		LLVMAddAttribute(Pointer.getPeer(Arg), (int)PA.value());
	}
	protected native static void LLVMAddAttribute(@Ptr long Arg, int PA);
	/**
	 * Remove an attribute from a function argument.<br>
	 * * @see llvm::Argument::removeAttr()<br>
	 * Original signature : <code>void LLVMRemoveAttribute(LLVMValueRef, LLVMAttribute)</code>
	 */
	public static void LLVMRemoveAttribute(LLVMLibrary.LLVMValueRef Arg, IntValuedEnum<LLVMLibrary.LLVMAttribute > PA) {
		LLVMRemoveAttribute(Pointer.getPeer(Arg), (int)PA.value());
	}
	protected native static void LLVMRemoveAttribute(@Ptr long Arg, int PA);
	/**
	 * Get an attribute from a function argument.<br>
	 * Original signature : <code>LLVMAttribute LLVMGetAttribute(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMAttribute > LLVMGetAttribute(LLVMLibrary.LLVMValueRef Arg) {
		return FlagSet.fromValue(LLVMGetAttribute(Pointer.getPeer(Arg)), LLVMLibrary.LLVMAttribute.class);
	}
	protected native static int LLVMGetAttribute(@Ptr long Arg);
	/**
	 * Set the alignment for a function parameter.<br>
	 * * @see llvm::Argument::addAttr()<br>
	 * @see llvm::AttrBuilder::addAlignmentAttr()<br>
	 * Original signature : <code>void LLVMSetParamAlignment(LLVMValueRef, unsigned)</code>
	 */
	public static void LLVMSetParamAlignment(LLVMLibrary.LLVMValueRef Arg, int align) {
		LLVMSetParamAlignment(Pointer.getPeer(Arg), align);
	}
	protected native static void LLVMSetParamAlignment(@Ptr long Arg, int align);
	/**
	 * Obtain a MDString value from a context.<br>
	 * * The returned instance corresponds to the llvm::MDString class.<br>
	 * * The instance is specified by string data of a specified length. The<br>
	 * string content is copied, so the backing memory can be freed after<br>
	 * this function returns.<br>
	 * Original signature : <code>LLVMValueRef LLVMMDStringInContext(LLVMContextRef, const char*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMMDStringInContext(LLVMLibrary.LLVMContextRef C, Pointer<Byte > Str, int SLen) {
		return new LLVMLibrary.LLVMValueRef(LLVMMDStringInContext(Pointer.getPeer(C), Pointer.getPeer(Str), SLen));
	}
	@Ptr 
	protected native static long LLVMMDStringInContext(@Ptr long C, @Ptr long Str, int SLen);
	/**
	 * Obtain a MDString value from the global context.<br>
	 * Original signature : <code>LLVMValueRef LLVMMDString(const char*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMMDString(Pointer<Byte > Str, int SLen) {
		return new LLVMLibrary.LLVMValueRef(LLVMMDString(Pointer.getPeer(Str), SLen));
	}
	@Ptr 
	protected native static long LLVMMDString(@Ptr long Str, int SLen);
	/**
	 * Obtain a MDNode value from a context.<br>
	 * * The returned value corresponds to the llvm::MDNode class.<br>
	 * Original signature : <code>LLVMValueRef LLVMMDNodeInContext(LLVMContextRef, LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMMDNodeInContext(LLVMLibrary.LLVMContextRef C, Pointer<LLVMLibrary.LLVMValueRef > Vals, int Count) {
		return new LLVMLibrary.LLVMValueRef(LLVMMDNodeInContext(Pointer.getPeer(C), Pointer.getPeer(Vals), Count));
	}
	@Ptr 
	protected native static long LLVMMDNodeInContext(@Ptr long C, @Ptr long Vals, int Count);
	/**
	 * Obtain a MDNode value from the global context.<br>
	 * Original signature : <code>LLVMValueRef LLVMMDNode(LLVMValueRef*, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMMDNode(Pointer<LLVMLibrary.LLVMValueRef > Vals, int Count) {
		return new LLVMLibrary.LLVMValueRef(LLVMMDNode(Pointer.getPeer(Vals), Count));
	}
	@Ptr 
	protected native static long LLVMMDNode(@Ptr long Vals, int Count);
	/**
	 * Obtain the underlying string from a MDString value.<br>
	 * * @param V Instance to obtain string from.<br>
	 * @param Len Memory address which will hold length of returned string.<br>
	 * @return String data in MDString.<br>
	 * Original signature : <code>char* LLVMGetMDString(LLVMValueRef, unsigned*)</code>
	 */
	public static Pointer<Byte > LLVMGetMDString(LLVMLibrary.LLVMValueRef V, Pointer<Integer > Len) {
		return Pointer.pointerToAddress(LLVMGetMDString(Pointer.getPeer(V), Pointer.getPeer(Len)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetMDString(@Ptr long V, @Ptr long Len);
	/**
	 * Obtain the number of operands from an MDNode value.<br>
	 * * @param V MDNode to get number of operands from.<br>
	 * @return Number of operands of the MDNode.<br>
	 * Original signature : <code>int LLVMGetMDNodeNumOperands(LLVMValueRef)</code>
	 */
	public static int LLVMGetMDNodeNumOperands(LLVMLibrary.LLVMValueRef V) {
		return LLVMGetMDNodeNumOperands(Pointer.getPeer(V));
	}
	protected native static int LLVMGetMDNodeNumOperands(@Ptr long V);
	/**
	 * Obtain the given MDNode's operands.<br>
	 * * The passed LLVMValueRef pointer should point to enough memory to hold all of<br>
	 * the operands of the given MDNode (see LLVMGetMDNodeNumOperands) as<br>
	 * LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the<br>
	 * MDNode's operands.<br>
	 * * @param V MDNode to get the operands from.<br>
	 * @param Dest Destination array for operands.<br>
	 * Original signature : <code>void LLVMGetMDNodeOperands(LLVMValueRef, LLVMValueRef*)</code>
	 */
	public static void LLVMGetMDNodeOperands(LLVMLibrary.LLVMValueRef V, Pointer<LLVMLibrary.LLVMValueRef > Dest) {
		LLVMGetMDNodeOperands(Pointer.getPeer(V), Pointer.getPeer(Dest));
	}
	protected native static void LLVMGetMDNodeOperands(@Ptr long V, @Ptr long Dest);
	/**
	 * Convert a basic block instance to a value type.<br>
	 * Original signature : <code>LLVMValueRef LLVMBasicBlockAsValue(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBasicBlockAsValue(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMBasicBlockAsValue(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMBasicBlockAsValue(@Ptr long BB);
	/**
	 * Determine whether a LLVMValueRef is itself a basic block.<br>
	 * Original signature : <code>LLVMBool LLVMValueIsBasicBlock(LLVMValueRef)</code>
	 */
	public static int LLVMValueIsBasicBlock(LLVMLibrary.LLVMValueRef Val) {
		return LLVMValueIsBasicBlock(Pointer.getPeer(Val));
	}
	protected native static int LLVMValueIsBasicBlock(@Ptr long Val);
	/**
	 * Convert a LLVMValueRef to a LLVMBasicBlockRef instance.<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMValueAsBasicBlock(LLVMLibrary.LLVMValueRef Val) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMValueAsBasicBlock(Pointer.getPeer(Val)));
	}
	@Ptr 
	protected native static long LLVMValueAsBasicBlock(@Ptr long Val);
	/**
	 * Obtain the function to which a basic block belongs.<br>
	 * * @see llvm::BasicBlock::getParent()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetBasicBlockParent(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetBasicBlockParent(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetBasicBlockParent(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetBasicBlockParent(@Ptr long BB);
	/**
	 * Obtain the terminator instruction for a basic block.<br>
	 * * If the basic block does not have a terminator (it is not well-formed<br>
	 * if it doesn't), then NULL is returned.<br>
	 * * The returned LLVMValueRef corresponds to a llvm::TerminatorInst.<br>
	 * * @see llvm::BasicBlock::getTerminator()<br>
	 * Original signature : <code>LLVMValueRef LLVMGetBasicBlockTerminator(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetBasicBlockTerminator(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetBasicBlockTerminator(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetBasicBlockTerminator(@Ptr long BB);
	/**
	 * Obtain the number of basic blocks in a function.<br>
	 * * @param Fn Function value to operate on.<br>
	 * Original signature : <code>int LLVMCountBasicBlocks(LLVMValueRef)</code>
	 */
	public static int LLVMCountBasicBlocks(LLVMLibrary.LLVMValueRef Fn) {
		return LLVMCountBasicBlocks(Pointer.getPeer(Fn));
	}
	protected native static int LLVMCountBasicBlocks(@Ptr long Fn);
	/**
	 * Obtain all of the basic blocks in a function.<br>
	 * * This operates on a function value. The BasicBlocks parameter is a<br>
	 * pointer to a pre-allocated array of LLVMBasicBlockRef of at least<br>
	 * LLVMCountBasicBlocks() in length. This array is populated with<br>
	 * LLVMBasicBlockRef instances.<br>
	 * Original signature : <code>void LLVMGetBasicBlocks(LLVMValueRef, LLVMBasicBlockRef*)</code>
	 */
	public static void LLVMGetBasicBlocks(LLVMLibrary.LLVMValueRef Fn, Pointer<LLVMLibrary.LLVMBasicBlockRef > BasicBlocks) {
		LLVMGetBasicBlocks(Pointer.getPeer(Fn), Pointer.getPeer(BasicBlocks));
	}
	protected native static void LLVMGetBasicBlocks(@Ptr long Fn, @Ptr long BasicBlocks);
	/**
	 * Obtain the first basic block in a function.<br>
	 * * The returned basic block can be used as an iterator. You will likely<br>
	 * eventually call into LLVMGetNextBasicBlock() with it.<br>
	 * * @see llvm::Function::begin()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetFirstBasicBlock(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetFirstBasicBlock(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetFirstBasicBlock(@Ptr long Fn);
	/**
	 * Obtain the last basic block in a function.<br>
	 * * @see llvm::Function::end()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetLastBasicBlock(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetLastBasicBlock(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetLastBasicBlock(@Ptr long Fn);
	/**
	 * Advance a basic block iterator.<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetNextBasicBlock(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetNextBasicBlock(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetNextBasicBlock(@Ptr long BB);
	/**
	 * Go backwards in a basic block iterator.<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetPreviousBasicBlock(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetPreviousBasicBlock(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousBasicBlock(@Ptr long BB);
	/**
	 * Obtain the basic block that corresponds to the entry point of a<br>
	 * function.<br>
	 * * @see llvm::Function::getEntryBlock()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetEntryBasicBlock(LLVMLibrary.LLVMValueRef Fn) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetEntryBasicBlock(Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMGetEntryBasicBlock(@Ptr long Fn);
	/**
	 * Append a basic block to the end of a function.<br>
	 * * @see llvm::BasicBlock::Create()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMContextRef, LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMAppendBasicBlockInContext(LLVMLibrary.LLVMContextRef C, LLVMLibrary.LLVMValueRef Fn, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMAppendBasicBlockInContext(Pointer.getPeer(C), Pointer.getPeer(Fn), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMAppendBasicBlockInContext(@Ptr long C, @Ptr long Fn, @Ptr long Name);
	/**
	 * Append a basic block to the end of a function using the global<br>
	 * context.<br>
	 * * @see llvm::BasicBlock::Create()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMAppendBasicBlock(LLVMLibrary.LLVMValueRef Fn, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMAppendBasicBlock(Pointer.getPeer(Fn), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMAppendBasicBlock(@Ptr long Fn, @Ptr long Name);
	/**
	 * Insert a basic block in a function before another basic block.<br>
	 * * The function to add to is determined by the function of the<br>
	 * passed basic block.<br>
	 * * @see llvm::BasicBlock::Create()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMContextRef, LLVMBasicBlockRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMInsertBasicBlockInContext(LLVMLibrary.LLVMContextRef C, LLVMLibrary.LLVMBasicBlockRef BB, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMInsertBasicBlockInContext(Pointer.getPeer(C), Pointer.getPeer(BB), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMInsertBasicBlockInContext(@Ptr long C, @Ptr long BB, @Ptr long Name);
	/**
	 * Insert a basic block in a function using the global context.<br>
	 * * @see llvm::BasicBlock::Create()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMBasicBlockRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMInsertBasicBlock(LLVMLibrary.LLVMBasicBlockRef InsertBeforeBB, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMInsertBasicBlock(Pointer.getPeer(InsertBeforeBB), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMInsertBasicBlock(@Ptr long InsertBeforeBB, @Ptr long Name);
	/**
	 * Remove a basic block from a function and delete it.<br>
	 * * This deletes the basic block from its containing function and deletes<br>
	 * the basic block itself.<br>
	 * * @see llvm::BasicBlock::eraseFromParent()<br>
	 * Original signature : <code>void LLVMDeleteBasicBlock(LLVMBasicBlockRef)</code>
	 */
	public static void LLVMDeleteBasicBlock(LLVMLibrary.LLVMBasicBlockRef BB) {
		LLVMDeleteBasicBlock(Pointer.getPeer(BB));
	}
	protected native static void LLVMDeleteBasicBlock(@Ptr long BB);
	/**
	 * Remove a basic block from a function.<br>
	 * * This deletes the basic block from its containing function but keep<br>
	 * the basic block alive.<br>
	 * * @see llvm::BasicBlock::removeFromParent()<br>
	 * Original signature : <code>void LLVMRemoveBasicBlockFromParent(LLVMBasicBlockRef)</code>
	 */
	public static void LLVMRemoveBasicBlockFromParent(LLVMLibrary.LLVMBasicBlockRef BB) {
		LLVMRemoveBasicBlockFromParent(Pointer.getPeer(BB));
	}
	protected native static void LLVMRemoveBasicBlockFromParent(@Ptr long BB);
	/**
	 * Move a basic block to before another one.<br>
	 * * @see llvm::BasicBlock::moveBefore()<br>
	 * Original signature : <code>void LLVMMoveBasicBlockBefore(LLVMBasicBlockRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMMoveBasicBlockBefore(LLVMLibrary.LLVMBasicBlockRef BB, LLVMLibrary.LLVMBasicBlockRef MovePos) {
		LLVMMoveBasicBlockBefore(Pointer.getPeer(BB), Pointer.getPeer(MovePos));
	}
	protected native static void LLVMMoveBasicBlockBefore(@Ptr long BB, @Ptr long MovePos);
	/**
	 * Move a basic block to after another one.<br>
	 * * @see llvm::BasicBlock::moveAfter()<br>
	 * Original signature : <code>void LLVMMoveBasicBlockAfter(LLVMBasicBlockRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMMoveBasicBlockAfter(LLVMLibrary.LLVMBasicBlockRef BB, LLVMLibrary.LLVMBasicBlockRef MovePos) {
		LLVMMoveBasicBlockAfter(Pointer.getPeer(BB), Pointer.getPeer(MovePos));
	}
	protected native static void LLVMMoveBasicBlockAfter(@Ptr long BB, @Ptr long MovePos);
	/**
	 * Obtain the first instruction in a basic block.<br>
	 * * The returned LLVMValueRef corresponds to a llvm::Instruction<br>
	 * instance.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetFirstInstruction(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetFirstInstruction(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetFirstInstruction(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetFirstInstruction(@Ptr long BB);
	/**
	 * Obtain the last instruction in a basic block.<br>
	 * * The returned LLVMValueRef corresponds to a LLVM:Instruction.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetLastInstruction(LLVMBasicBlockRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetLastInstruction(LLVMLibrary.LLVMBasicBlockRef BB) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetLastInstruction(Pointer.getPeer(BB)));
	}
	@Ptr 
	protected native static long LLVMGetLastInstruction(@Ptr long BB);
	/**
	 * Determine whether an instruction has any metadata attached.<br>
	 * Original signature : <code>int LLVMHasMetadata(LLVMValueRef)</code>
	 */
	public static int LLVMHasMetadata(LLVMLibrary.LLVMValueRef Val) {
		return LLVMHasMetadata(Pointer.getPeer(Val));
	}
	protected native static int LLVMHasMetadata(@Ptr long Val);
	/**
	 * Return metadata associated with an instruction value.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetMetadata(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetMetadata(LLVMLibrary.LLVMValueRef Val, int KindID) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetMetadata(Pointer.getPeer(Val), KindID));
	}
	@Ptr 
	protected native static long LLVMGetMetadata(@Ptr long Val, int KindID);
	/**
	 * Set metadata associated with an instruction value.<br>
	 * Original signature : <code>void LLVMSetMetadata(LLVMValueRef, unsigned, LLVMValueRef)</code>
	 */
	public static void LLVMSetMetadata(LLVMLibrary.LLVMValueRef Val, int KindID, LLVMLibrary.LLVMValueRef Node) {
		LLVMSetMetadata(Pointer.getPeer(Val), KindID, Pointer.getPeer(Node));
	}
	protected native static void LLVMSetMetadata(@Ptr long Val, int KindID, @Ptr long Node);
	/**
	 * Obtain the basic block to which an instruction belongs.<br>
	 * * @see llvm::Instruction::getParent()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetInstructionParent(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetInstructionParent(LLVMLibrary.LLVMValueRef Inst) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetInstructionParent(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMGetInstructionParent(@Ptr long Inst);
	/**
	 * Obtain the instruction that occurs after the one specified.<br>
	 * * The next instruction will be from the same basic block.<br>
	 * * If this is the last instruction in a basic block, NULL will be<br>
	 * returned.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetNextInstruction(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetNextInstruction(LLVMLibrary.LLVMValueRef Inst) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetNextInstruction(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMGetNextInstruction(@Ptr long Inst);
	/**
	 * Obtain the instruction that occurred before this one.<br>
	 * * If the instruction is the first instruction in a basic block, NULL<br>
	 * will be returned.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetPreviousInstruction(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetPreviousInstruction(LLVMLibrary.LLVMValueRef Inst) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetPreviousInstruction(Pointer.getPeer(Inst)));
	}
	@Ptr 
	protected native static long LLVMGetPreviousInstruction(@Ptr long Inst);
	/**
	 * Remove and delete an instruction.<br>
	 * * The instruction specified is removed from its containing building<br>
	 * block and then deleted.<br>
	 * * @see llvm::Instruction::eraseFromParent()<br>
	 * Original signature : <code>void LLVMInstructionEraseFromParent(LLVMValueRef)</code>
	 */
	public static void LLVMInstructionEraseFromParent(LLVMLibrary.LLVMValueRef Inst) {
		LLVMInstructionEraseFromParent(Pointer.getPeer(Inst));
	}
	protected native static void LLVMInstructionEraseFromParent(@Ptr long Inst);
	/**
	 * Obtain the code opcode for an individual instruction.<br>
	 * * @see llvm::Instruction::getOpCode()<br>
	 * Original signature : <code>LLVMOpcode LLVMGetInstructionOpcode(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMOpcode > LLVMGetInstructionOpcode(LLVMLibrary.LLVMValueRef Inst) {
		return FlagSet.fromValue(LLVMGetInstructionOpcode(Pointer.getPeer(Inst)), LLVMLibrary.LLVMOpcode.class);
	}
	protected native static int LLVMGetInstructionOpcode(@Ptr long Inst);
	/**
	 * Obtain the predicate of an instruction.<br>
	 * * This is only valid for instructions that correspond to llvm::ICmpInst<br>
	 * or llvm::ConstantExpr whose opcode is llvm::Instruction::ICmp.<br>
	 * * @see llvm::ICmpInst::getPredicate()<br>
	 * Original signature : <code>LLVMIntPredicate LLVMGetICmpPredicate(LLVMValueRef)</code>
	 */
	public static IntValuedEnum<LLVMLibrary.LLVMIntPredicate > LLVMGetICmpPredicate(LLVMLibrary.LLVMValueRef Inst) {
		return FlagSet.fromValue(LLVMGetICmpPredicate(Pointer.getPeer(Inst)), LLVMLibrary.LLVMIntPredicate.class);
	}
	protected native static int LLVMGetICmpPredicate(@Ptr long Inst);
	/**
	 * Set the calling convention for a call instruction.<br>
	 * * This expects an LLVMValueRef that corresponds to a llvm::CallInst or<br>
	 * llvm::InvokeInst.<br>
	 * * @see llvm::CallInst::setCallingConv()<br>
	 * @see llvm::InvokeInst::setCallingConv()<br>
	 * Original signature : <code>void LLVMSetInstructionCallConv(LLVMValueRef, unsigned)</code>
	 */
	public static void LLVMSetInstructionCallConv(LLVMLibrary.LLVMValueRef Instr, int CC) {
		LLVMSetInstructionCallConv(Pointer.getPeer(Instr), CC);
	}
	protected native static void LLVMSetInstructionCallConv(@Ptr long Instr, int CC);
	/**
	 * Obtain the calling convention for a call instruction.<br>
	 * * This is the opposite of LLVMSetInstructionCallConv(). Reads its<br>
	 * usage.<br>
	 * * @see LLVMSetInstructionCallConv()<br>
	 * Original signature : <code>int LLVMGetInstructionCallConv(LLVMValueRef)</code>
	 */
	public static int LLVMGetInstructionCallConv(LLVMLibrary.LLVMValueRef Instr) {
		return LLVMGetInstructionCallConv(Pointer.getPeer(Instr));
	}
	protected native static int LLVMGetInstructionCallConv(@Ptr long Instr);
	/// Original signature : <code>void LLVMAddInstrAttribute(LLVMValueRef, unsigned, LLVMAttribute)</code>
	public static void LLVMAddInstrAttribute(LLVMLibrary.LLVMValueRef Instr, int index, IntValuedEnum<LLVMLibrary.LLVMAttribute > LLVMAttribute1) {
		LLVMAddInstrAttribute(Pointer.getPeer(Instr), index, (int)LLVMAttribute1.value());
	}
	protected native static void LLVMAddInstrAttribute(@Ptr long Instr, int index, int LLVMAttribute1);
	/// Original signature : <code>void LLVMRemoveInstrAttribute(LLVMValueRef, unsigned, LLVMAttribute)</code>
	public static void LLVMRemoveInstrAttribute(LLVMLibrary.LLVMValueRef Instr, int index, IntValuedEnum<LLVMLibrary.LLVMAttribute > LLVMAttribute1) {
		LLVMRemoveInstrAttribute(Pointer.getPeer(Instr), index, (int)LLVMAttribute1.value());
	}
	protected native static void LLVMRemoveInstrAttribute(@Ptr long Instr, int index, int LLVMAttribute1);
	/// Original signature : <code>void LLVMSetInstrParamAlignment(LLVMValueRef, unsigned, unsigned)</code>
	public static void LLVMSetInstrParamAlignment(LLVMLibrary.LLVMValueRef Instr, int index, int align) {
		LLVMSetInstrParamAlignment(Pointer.getPeer(Instr), index, align);
	}
	protected native static void LLVMSetInstrParamAlignment(@Ptr long Instr, int index, int align);
	/**
	 * Obtain whether a call instruction is a tail call.<br>
	 * * This only works on llvm::CallInst instructions.<br>
	 * * @see llvm::CallInst::isTailCall()<br>
	 * Original signature : <code>LLVMBool LLVMIsTailCall(LLVMValueRef)</code>
	 */
	public static int LLVMIsTailCall(LLVMLibrary.LLVMValueRef CallInst) {
		return LLVMIsTailCall(Pointer.getPeer(CallInst));
	}
	protected native static int LLVMIsTailCall(@Ptr long CallInst);
	/**
	 * Set whether a call instruction is a tail call.<br>
	 * * This only works on llvm::CallInst instructions.<br>
	 * * @see llvm::CallInst::setTailCall()<br>
	 * Original signature : <code>void LLVMSetTailCall(LLVMValueRef, LLVMBool)</code>
	 */
	public static void LLVMSetTailCall(LLVMLibrary.LLVMValueRef CallInst, int IsTailCall) {
		LLVMSetTailCall(Pointer.getPeer(CallInst), IsTailCall);
	}
	protected native static void LLVMSetTailCall(@Ptr long CallInst, int IsTailCall);
	/**
	 * Obtain the default destination basic block of a switch instruction.<br>
	 * * This only works on llvm::SwitchInst instructions.<br>
	 * * @see llvm::SwitchInst::getDefaultDest()<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMValueRef)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetSwitchDefaultDest(LLVMLibrary.LLVMValueRef SwitchInstr) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetSwitchDefaultDest(Pointer.getPeer(SwitchInstr)));
	}
	@Ptr 
	protected native static long LLVMGetSwitchDefaultDest(@Ptr long SwitchInstr);
	/**
	 * Add an incoming value to the end of a PHI list.<br>
	 * Original signature : <code>void LLVMAddIncoming(LLVMValueRef, LLVMValueRef*, LLVMBasicBlockRef*, unsigned)</code>
	 */
	public static void LLVMAddIncoming(LLVMLibrary.LLVMValueRef PhiNode, Pointer<LLVMLibrary.LLVMValueRef > IncomingValues, Pointer<LLVMLibrary.LLVMBasicBlockRef > IncomingBlocks, int Count) {
		LLVMAddIncoming(Pointer.getPeer(PhiNode), Pointer.getPeer(IncomingValues), Pointer.getPeer(IncomingBlocks), Count);
	}
	protected native static void LLVMAddIncoming(@Ptr long PhiNode, @Ptr long IncomingValues, @Ptr long IncomingBlocks, int Count);
	/**
	 * Obtain the number of incoming basic blocks to a PHI node.<br>
	 * Original signature : <code>int LLVMCountIncoming(LLVMValueRef)</code>
	 */
	public static int LLVMCountIncoming(LLVMLibrary.LLVMValueRef PhiNode) {
		return LLVMCountIncoming(Pointer.getPeer(PhiNode));
	}
	protected native static int LLVMCountIncoming(@Ptr long PhiNode);
	/**
	 * Obtain an incoming value to a PHI node as a LLVMValueRef.<br>
	 * Original signature : <code>LLVMValueRef LLVMGetIncomingValue(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMGetIncomingValue(LLVMLibrary.LLVMValueRef PhiNode, int Index) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetIncomingValue(Pointer.getPeer(PhiNode), Index));
	}
	@Ptr 
	protected native static long LLVMGetIncomingValue(@Ptr long PhiNode, int Index);
	/**
	 * Obtain an incoming value to a PHI node as a LLVMBasicBlockRef.<br>
	 * Original signature : <code>LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMValueRef, unsigned)</code>
	 */
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetIncomingBlock(LLVMLibrary.LLVMValueRef PhiNode, int Index) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetIncomingBlock(Pointer.getPeer(PhiNode), Index));
	}
	@Ptr 
	protected native static long LLVMGetIncomingBlock(@Ptr long PhiNode, int Index);
	/// Original signature : <code>LLVMBuilderRef LLVMCreateBuilderInContext(LLVMContextRef)</code>
	public static LLVMLibrary.LLVMBuilderRef LLVMCreateBuilderInContext(LLVMLibrary.LLVMContextRef C) {
		return new LLVMLibrary.LLVMBuilderRef(LLVMCreateBuilderInContext(Pointer.getPeer(C)));
	}
	@Ptr 
	protected native static long LLVMCreateBuilderInContext(@Ptr long C);
	/// Original signature : <code>LLVMBuilderRef LLVMCreateBuilder()</code>
	public static LLVMLibrary.LLVMBuilderRef LLVMCreateBuilder() {
		return new LLVMLibrary.LLVMBuilderRef(LLVMCreateBuilder$2());
	}
	@Ptr 
	@Name("LLVMCreateBuilder") 
	protected native static long LLVMCreateBuilder$2();
	/// Original signature : <code>void LLVMPositionBuilder(LLVMBuilderRef, LLVMBasicBlockRef, LLVMValueRef)</code>
	public static void LLVMPositionBuilder(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMBasicBlockRef Block, LLVMLibrary.LLVMValueRef Instr) {
		LLVMPositionBuilder(Pointer.getPeer(Builder), Pointer.getPeer(Block), Pointer.getPeer(Instr));
	}
	protected native static void LLVMPositionBuilder(@Ptr long Builder, @Ptr long Block, @Ptr long Instr);
	/// Original signature : <code>void LLVMPositionBuilderBefore(LLVMBuilderRef, LLVMValueRef)</code>
	public static void LLVMPositionBuilderBefore(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef Instr) {
		LLVMPositionBuilderBefore(Pointer.getPeer(Builder), Pointer.getPeer(Instr));
	}
	protected native static void LLVMPositionBuilderBefore(@Ptr long Builder, @Ptr long Instr);
	/// Original signature : <code>void LLVMPositionBuilderAtEnd(LLVMBuilderRef, LLVMBasicBlockRef)</code>
	public static void LLVMPositionBuilderAtEnd(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMBasicBlockRef Block) {
		LLVMPositionBuilderAtEnd(Pointer.getPeer(Builder), Pointer.getPeer(Block));
	}
	protected native static void LLVMPositionBuilderAtEnd(@Ptr long Builder, @Ptr long Block);
	/// Original signature : <code>LLVMBasicBlockRef LLVMGetInsertBlock(LLVMBuilderRef)</code>
	public static LLVMLibrary.LLVMBasicBlockRef LLVMGetInsertBlock(LLVMLibrary.LLVMBuilderRef Builder) {
		return new LLVMLibrary.LLVMBasicBlockRef(LLVMGetInsertBlock(Pointer.getPeer(Builder)));
	}
	@Ptr 
	protected native static long LLVMGetInsertBlock(@Ptr long Builder);
	/// Original signature : <code>void LLVMClearInsertionPosition(LLVMBuilderRef)</code>
	public static void LLVMClearInsertionPosition(LLVMLibrary.LLVMBuilderRef Builder) {
		LLVMClearInsertionPosition(Pointer.getPeer(Builder));
	}
	protected native static void LLVMClearInsertionPosition(@Ptr long Builder);
	/// Original signature : <code>void LLVMInsertIntoBuilder(LLVMBuilderRef, LLVMValueRef)</code>
	public static void LLVMInsertIntoBuilder(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef Instr) {
		LLVMInsertIntoBuilder(Pointer.getPeer(Builder), Pointer.getPeer(Instr));
	}
	protected native static void LLVMInsertIntoBuilder(@Ptr long Builder, @Ptr long Instr);
	/// Original signature : <code>void LLVMInsertIntoBuilderWithName(LLVMBuilderRef, LLVMValueRef, const char*)</code>
	public static void LLVMInsertIntoBuilderWithName(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef Instr, Pointer<Byte > Name) {
		LLVMInsertIntoBuilderWithName(Pointer.getPeer(Builder), Pointer.getPeer(Instr), Pointer.getPeer(Name));
	}
	protected native static void LLVMInsertIntoBuilderWithName(@Ptr long Builder, @Ptr long Instr, @Ptr long Name);
	/// Original signature : <code>void LLVMDisposeBuilder(LLVMBuilderRef)</code>
	public static void LLVMDisposeBuilder(LLVMLibrary.LLVMBuilderRef Builder) {
		LLVMDisposeBuilder(Pointer.getPeer(Builder));
	}
	protected native static void LLVMDisposeBuilder(@Ptr long Builder);
	/**
	 * Metadata<br>
	 * Original signature : <code>void LLVMSetCurrentDebugLocation(LLVMBuilderRef, LLVMValueRef)</code>
	 */
	public static void LLVMSetCurrentDebugLocation(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef L) {
		LLVMSetCurrentDebugLocation(Pointer.getPeer(Builder), Pointer.getPeer(L));
	}
	protected native static void LLVMSetCurrentDebugLocation(@Ptr long Builder, @Ptr long L);
	/// Original signature : <code>LLVMValueRef LLVMGetCurrentDebugLocation(LLVMBuilderRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMGetCurrentDebugLocation(LLVMLibrary.LLVMBuilderRef Builder) {
		return new LLVMLibrary.LLVMValueRef(LLVMGetCurrentDebugLocation(Pointer.getPeer(Builder)));
	}
	@Ptr 
	protected native static long LLVMGetCurrentDebugLocation(@Ptr long Builder);
	/// Original signature : <code>void LLVMSetInstDebugLocation(LLVMBuilderRef, LLVMValueRef)</code>
	public static void LLVMSetInstDebugLocation(LLVMLibrary.LLVMBuilderRef Builder, LLVMLibrary.LLVMValueRef Inst) {
		LLVMSetInstDebugLocation(Pointer.getPeer(Builder), Pointer.getPeer(Inst));
	}
	protected native static void LLVMSetInstDebugLocation(@Ptr long Builder, @Ptr long Inst);
	/**
	 * Terminators<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildRetVoid(LLVMBuilderRef)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildRetVoid(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildRetVoid(Pointer.getPeer(LLVMBuilderRef1)));
	}
	@Ptr 
	protected native static long LLVMBuildRetVoid(@Ptr long LLVMBuilderRef1);
	/// Original signature : <code>LLVMValueRef LLVMBuildRet(LLVMBuilderRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildRet(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef V) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildRet(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(V)));
	}
	@Ptr 
	protected native static long LLVMBuildRet(@Ptr long LLVMBuilderRef1, @Ptr long V);
	/// Original signature : <code>LLVMValueRef LLVMBuildAggregateRet(LLVMBuilderRef, LLVMValueRef*, unsigned)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildAggregateRet(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, Pointer<LLVMLibrary.LLVMValueRef > RetVals, int N) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAggregateRet(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(RetVals), N));
	}
	@Ptr 
	protected native static long LLVMBuildAggregateRet(@Ptr long LLVMBuilderRef1, @Ptr long RetVals, int N);
	/// Original signature : <code>LLVMValueRef LLVMBuildBr(LLVMBuilderRef, LLVMBasicBlockRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildBr(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMBasicBlockRef Dest) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildBr(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Dest)));
	}
	@Ptr 
	protected native static long LLVMBuildBr(@Ptr long LLVMBuilderRef1, @Ptr long Dest);
	/// Original signature : <code>LLVMValueRef LLVMBuildCondBr(LLVMBuilderRef, LLVMValueRef, LLVMBasicBlockRef, LLVMBasicBlockRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildCondBr(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef If, LLVMLibrary.LLVMBasicBlockRef Then, LLVMLibrary.LLVMBasicBlockRef Else) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildCondBr(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(If), Pointer.getPeer(Then), Pointer.getPeer(Else)));
	}
	@Ptr 
	protected native static long LLVMBuildCondBr(@Ptr long LLVMBuilderRef1, @Ptr long If, @Ptr long Then, @Ptr long Else);
	/// Original signature : <code>LLVMValueRef LLVMBuildSwitch(LLVMBuilderRef, LLVMValueRef, LLVMBasicBlockRef, unsigned)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildSwitch(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef V, LLVMLibrary.LLVMBasicBlockRef Else, int NumCases) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSwitch(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(V), Pointer.getPeer(Else), NumCases));
	}
	@Ptr 
	protected native static long LLVMBuildSwitch(@Ptr long LLVMBuilderRef1, @Ptr long V, @Ptr long Else, int NumCases);
	/// Original signature : <code>LLVMValueRef LLVMBuildIndirectBr(LLVMBuilderRef, LLVMValueRef, unsigned)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildIndirectBr(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Addr, int NumDests) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIndirectBr(Pointer.getPeer(B), Pointer.getPeer(Addr), NumDests));
	}
	@Ptr 
	protected native static long LLVMBuildIndirectBr(@Ptr long B, @Ptr long Addr, int NumDests);
	/// Original signature : <code>LLVMValueRef LLVMBuildInvoke(LLVMBuilderRef, LLVMValueRef, LLVMValueRef*, unsigned, LLVMBasicBlockRef, LLVMBasicBlockRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildInvoke(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Fn, Pointer<LLVMLibrary.LLVMValueRef > Args, int NumArgs, LLVMLibrary.LLVMBasicBlockRef Then, LLVMLibrary.LLVMBasicBlockRef Catch, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildInvoke(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Fn), Pointer.getPeer(Args), NumArgs, Pointer.getPeer(Then), Pointer.getPeer(Catch), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildInvoke(@Ptr long LLVMBuilderRef1, @Ptr long Fn, @Ptr long Args, int NumArgs, @Ptr long Then, @Ptr long Catch, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildLandingPad(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef, unsigned, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildLandingPad(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMTypeRef Ty, LLVMLibrary.LLVMValueRef PersFn, int NumClauses, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildLandingPad(Pointer.getPeer(B), Pointer.getPeer(Ty), Pointer.getPeer(PersFn), NumClauses, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildLandingPad(@Ptr long B, @Ptr long Ty, @Ptr long PersFn, int NumClauses, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildResume(LLVMBuilderRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildResume(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Exn) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildResume(Pointer.getPeer(B), Pointer.getPeer(Exn)));
	}
	@Ptr 
	protected native static long LLVMBuildResume(@Ptr long B, @Ptr long Exn);
	/// Original signature : <code>LLVMValueRef LLVMBuildUnreachable(LLVMBuilderRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildUnreachable(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildUnreachable(Pointer.getPeer(LLVMBuilderRef1)));
	}
	@Ptr 
	protected native static long LLVMBuildUnreachable(@Ptr long LLVMBuilderRef1);
	/**
	 * Add a case to the switch instruction<br>
	 * Original signature : <code>void LLVMAddCase(LLVMValueRef, LLVMValueRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMAddCase(LLVMLibrary.LLVMValueRef Switch, LLVMLibrary.LLVMValueRef OnVal, LLVMLibrary.LLVMBasicBlockRef Dest) {
		LLVMAddCase(Pointer.getPeer(Switch), Pointer.getPeer(OnVal), Pointer.getPeer(Dest));
	}
	protected native static void LLVMAddCase(@Ptr long Switch, @Ptr long OnVal, @Ptr long Dest);
	/**
	 * Add a destination to the indirectbr instruction<br>
	 * Original signature : <code>void LLVMAddDestination(LLVMValueRef, LLVMBasicBlockRef)</code>
	 */
	public static void LLVMAddDestination(LLVMLibrary.LLVMValueRef IndirectBr, LLVMLibrary.LLVMBasicBlockRef Dest) {
		LLVMAddDestination(Pointer.getPeer(IndirectBr), Pointer.getPeer(Dest));
	}
	protected native static void LLVMAddDestination(@Ptr long IndirectBr, @Ptr long Dest);
	/**
	 * Add a catch or filter clause to the landingpad instruction<br>
	 * Original signature : <code>void LLVMAddClause(LLVMValueRef, LLVMValueRef)</code>
	 */
	public static void LLVMAddClause(LLVMLibrary.LLVMValueRef LandingPad, LLVMLibrary.LLVMValueRef ClauseVal) {
		LLVMAddClause(Pointer.getPeer(LandingPad), Pointer.getPeer(ClauseVal));
	}
	protected native static void LLVMAddClause(@Ptr long LandingPad, @Ptr long ClauseVal);
	/**
	 * Set the 'cleanup' flag in the landingpad instruction<br>
	 * Original signature : <code>void LLVMSetCleanup(LLVMValueRef, LLVMBool)</code>
	 */
	public static void LLVMSetCleanup(LLVMLibrary.LLVMValueRef LandingPad, int Val) {
		LLVMSetCleanup(Pointer.getPeer(LandingPad), Val);
	}
	protected native static void LLVMSetCleanup(@Ptr long LandingPad, int Val);
	/**
	 * Arithmetic<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildAdd(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildAdd(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAdd(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildAdd(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNSWAdd(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNSWAdd(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNSWAdd(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNSWAdd(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNUWAdd(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNUWAdd(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNUWAdd(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNUWAdd(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFAdd(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFAdd(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFAdd(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFAdd(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildSub(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildSub(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSub(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSub(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNSWSub(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNSWSub(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNSWSub(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNSWSub(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNUWSub(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNUWSub(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNUWSub(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNUWSub(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFSub(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFSub(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFSub(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFSub(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildMul(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildMul(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildMul(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildMul(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNSWMul(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNSWMul(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNSWMul(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNSWMul(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNUWMul(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNUWMul(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNUWMul(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNUWMul(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFMul(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFMul(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFMul(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFMul(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildUDiv(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildUDiv(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildUDiv(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildUDiv(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildSDiv(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildSDiv(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSDiv(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSDiv(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildExactSDiv(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildExactSDiv(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildExactSDiv(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildExactSDiv(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFDiv(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFDiv(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFDiv(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFDiv(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildURem(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildURem(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildURem(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildURem(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildSRem(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildSRem(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSRem(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSRem(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFRem(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFRem(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFRem(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFRem(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildShl(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildShl(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildShl(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildShl(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildLShr(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildLShr(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildLShr(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildLShr(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildAShr(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildAShr(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAShr(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildAShr(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildAnd(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildAnd(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAnd(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildAnd(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildOr(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildOr(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildOr(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildOr(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildXor(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildXor(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildXor(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildXor(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildBinOp(LLVMBuilderRef, LLVMOpcode, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildBinOp(LLVMLibrary.LLVMBuilderRef B, IntValuedEnum<LLVMLibrary.LLVMOpcode > Op, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildBinOp(Pointer.getPeer(B), (int)Op.value(), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildBinOp(@Ptr long B, int Op, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNeg(LLVMBuilderRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNeg(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNeg(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNeg(@Ptr long LLVMBuilderRef1, @Ptr long V, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNSWNeg(LLVMBuilderRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNSWNeg(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNSWNeg(Pointer.getPeer(B), Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNSWNeg(@Ptr long B, @Ptr long V, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNUWNeg(LLVMBuilderRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNUWNeg(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNUWNeg(Pointer.getPeer(B), Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNUWNeg(@Ptr long B, @Ptr long V, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFNeg(LLVMBuilderRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFNeg(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFNeg(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFNeg(@Ptr long LLVMBuilderRef1, @Ptr long V, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildNot(LLVMBuilderRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildNot(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef V, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildNot(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(V), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildNot(@Ptr long LLVMBuilderRef1, @Ptr long V, @Ptr long Name);
	/**
	 * Memory<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildMalloc(LLVMBuilderRef, LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildMalloc(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildMalloc(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildMalloc(@Ptr long LLVMBuilderRef1, @Ptr long Ty, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildArrayMalloc(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildArrayMalloc(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMTypeRef Ty, LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildArrayMalloc(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Ty), Pointer.getPeer(Val), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildArrayMalloc(@Ptr long LLVMBuilderRef1, @Ptr long Ty, @Ptr long Val, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildAlloca(LLVMBuilderRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildAlloca(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAlloca(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildAlloca(@Ptr long LLVMBuilderRef1, @Ptr long Ty, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildArrayAlloca(LLVMBuilderRef, LLVMTypeRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildArrayAlloca(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMTypeRef Ty, LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildArrayAlloca(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Ty), Pointer.getPeer(Val), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildArrayAlloca(@Ptr long LLVMBuilderRef1, @Ptr long Ty, @Ptr long Val, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFree(LLVMBuilderRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFree(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef PointerVal) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFree(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(PointerVal)));
	}
	@Ptr 
	protected native static long LLVMBuildFree(@Ptr long LLVMBuilderRef1, @Ptr long PointerVal);
	/// Original signature : <code>LLVMValueRef LLVMBuildLoad(LLVMBuilderRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildLoad(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef PointerVal, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildLoad(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(PointerVal), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildLoad(@Ptr long LLVMBuilderRef1, @Ptr long PointerVal, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildStore(LLVMBuilderRef, LLVMValueRef, LLVMValueRef)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildStore(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMValueRef Ptr) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildStore(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(Ptr)));
	}
	@Ptr 
	protected native static long LLVMBuildStore(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long Ptr);
	/// Original signature : <code>LLVMValueRef LLVMBuildGEP(LLVMBuilderRef, LLVMValueRef, LLVMValueRef*, unsigned, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildGEP(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Pointer, Pointer<LLVMLibrary.LLVMValueRef > Indices, int NumIndices, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildGEP(Pointer.getPeer(B), Pointer.getPeer(Pointer), Pointer.getPeer(Indices), NumIndices, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildGEP(@Ptr long B, @Ptr long Pointer, @Ptr long Indices, int NumIndices, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildInBoundsGEP(LLVMBuilderRef, LLVMValueRef, LLVMValueRef*, unsigned, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildInBoundsGEP(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Pointer, Pointer<LLVMLibrary.LLVMValueRef > Indices, int NumIndices, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildInBoundsGEP(Pointer.getPeer(B), Pointer.getPeer(Pointer), Pointer.getPeer(Indices), NumIndices, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildInBoundsGEP(@Ptr long B, @Ptr long Pointer, @Ptr long Indices, int NumIndices, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildStructGEP(LLVMBuilderRef, LLVMValueRef, unsigned, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildStructGEP(LLVMLibrary.LLVMBuilderRef B, LLVMLibrary.LLVMValueRef Pointer, int Idx, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildStructGEP(Pointer.getPeer(B), Pointer.getPeer(Pointer), Idx, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildStructGEP(@Ptr long B, @Ptr long Pointer, int Idx, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildGlobalString(LLVMBuilderRef, const char*, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildGlobalString(LLVMLibrary.LLVMBuilderRef B, Pointer<Byte > Str, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildGlobalString(Pointer.getPeer(B), Pointer.getPeer(Str), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildGlobalString(@Ptr long B, @Ptr long Str, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildGlobalStringPtr(LLVMBuilderRef, const char*, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildGlobalStringPtr(LLVMLibrary.LLVMBuilderRef B, Pointer<Byte > Str, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildGlobalStringPtr(Pointer.getPeer(B), Pointer.getPeer(Str), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildGlobalStringPtr(@Ptr long B, @Ptr long Str, @Ptr long Name);
	/// Original signature : <code>LLVMBool LLVMGetVolatile(LLVMValueRef)</code>
	public static int LLVMGetVolatile(LLVMLibrary.LLVMValueRef MemoryAccessInst) {
		return LLVMGetVolatile(Pointer.getPeer(MemoryAccessInst));
	}
	protected native static int LLVMGetVolatile(@Ptr long MemoryAccessInst);
	/// Original signature : <code>void LLVMSetVolatile(LLVMValueRef, LLVMBool)</code>
	public static void LLVMSetVolatile(LLVMLibrary.LLVMValueRef MemoryAccessInst, int IsVolatile) {
		LLVMSetVolatile(Pointer.getPeer(MemoryAccessInst), IsVolatile);
	}
	protected native static void LLVMSetVolatile(@Ptr long MemoryAccessInst, int IsVolatile);
	/**
	 * Casts<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildTrunc(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildTrunc(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildTrunc(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildTrunc(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildZExt(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildZExt(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildZExt(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildZExt(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildSExt(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildSExt(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSExt(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSExt(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFPToUI(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPToUI(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPToUI(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPToUI(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFPToSI(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPToSI(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPToSI(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPToSI(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildUIToFP(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildUIToFP(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildUIToFP(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildUIToFP(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildSIToFP(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildSIToFP(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSIToFP(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSIToFP(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFPTrunc(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPTrunc(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPTrunc(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPTrunc(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFPExt(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPExt(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPExt(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPExt(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildPtrToInt(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildPtrToInt(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildPtrToInt(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildPtrToInt(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildIntToPtr(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildIntToPtr(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIntToPtr(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildIntToPtr(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildBitCast(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildBitCast(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildBitCast(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildBitCast(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildZExtOrBitCast(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildZExtOrBitCast(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildZExtOrBitCast(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildZExtOrBitCast(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildSExtOrBitCast(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildSExtOrBitCast(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSExtOrBitCast(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSExtOrBitCast(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildTruncOrBitCast(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildTruncOrBitCast(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildTruncOrBitCast(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildTruncOrBitCast(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildCast(LLVMBuilderRef, LLVMOpcode, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildCast(LLVMLibrary.LLVMBuilderRef B, IntValuedEnum<LLVMLibrary.LLVMOpcode > Op, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildCast(Pointer.getPeer(B), (int)Op.value(), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildCast(@Ptr long B, int Op, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildPointerCast(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildPointerCast(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildPointerCast(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildPointerCast(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/**
	 * Signed cast!<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildIntCast(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code><br>
	 * @param LLVMBuilderRef1 Signed cast!<br>
	 * @param Val Signed cast!
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildIntCast(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIntCast(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildIntCast(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFPCast(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFPCast(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, LLVMLibrary.LLVMTypeRef DestTy, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFPCast(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(DestTy), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFPCast(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long DestTy, @Ptr long Name);
	/**
	 * Comparisons<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildICmp(LLVMBuilderRef, LLVMIntPredicate, LLVMValueRef, LLVMValueRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildICmp(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, IntValuedEnum<LLVMLibrary.LLVMIntPredicate > Op, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildICmp(Pointer.getPeer(LLVMBuilderRef1), (int)Op.value(), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildICmp(@Ptr long LLVMBuilderRef1, int Op, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildFCmp(LLVMBuilderRef, LLVMRealPredicate, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildFCmp(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, IntValuedEnum<LLVMLibrary.LLVMRealPredicate > Op, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildFCmp(Pointer.getPeer(LLVMBuilderRef1), (int)Op.value(), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildFCmp(@Ptr long LLVMBuilderRef1, int Op, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/**
	 * Miscellaneous instructions<br>
	 * Original signature : <code>LLVMValueRef LLVMBuildPhi(LLVMBuilderRef, LLVMTypeRef, const char*)</code>
	 */
	public static LLVMLibrary.LLVMValueRef LLVMBuildPhi(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildPhi(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildPhi(@Ptr long LLVMBuilderRef1, @Ptr long Ty, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildCall(LLVMBuilderRef, LLVMValueRef, LLVMValueRef*, unsigned, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildCall(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Fn, Pointer<LLVMLibrary.LLVMValueRef > Args, int NumArgs, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildCall(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Fn), Pointer.getPeer(Args), NumArgs, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildCall(@Ptr long LLVMBuilderRef1, @Ptr long Fn, @Ptr long Args, int NumArgs, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildSelect(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildSelect(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef If, LLVMLibrary.LLVMValueRef Then, LLVMLibrary.LLVMValueRef Else, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildSelect(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(If), Pointer.getPeer(Then), Pointer.getPeer(Else), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildSelect(@Ptr long LLVMBuilderRef1, @Ptr long If, @Ptr long Then, @Ptr long Else, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildVAArg(LLVMBuilderRef, LLVMValueRef, LLVMTypeRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildVAArg(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef List, LLVMLibrary.LLVMTypeRef Ty, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildVAArg(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(List), Pointer.getPeer(Ty), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildVAArg(@Ptr long LLVMBuilderRef1, @Ptr long List, @Ptr long Ty, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildExtractElement(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildExtractElement(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef VecVal, LLVMLibrary.LLVMValueRef Index, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildExtractElement(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(VecVal), Pointer.getPeer(Index), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildExtractElement(@Ptr long LLVMBuilderRef1, @Ptr long VecVal, @Ptr long Index, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildInsertElement(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildInsertElement(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef VecVal, LLVMLibrary.LLVMValueRef EltVal, LLVMLibrary.LLVMValueRef Index, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildInsertElement(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(VecVal), Pointer.getPeer(EltVal), Pointer.getPeer(Index), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildInsertElement(@Ptr long LLVMBuilderRef1, @Ptr long VecVal, @Ptr long EltVal, @Ptr long Index, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildShuffleVector(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildShuffleVector(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef V1, LLVMLibrary.LLVMValueRef V2, LLVMLibrary.LLVMValueRef Mask, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildShuffleVector(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(V1), Pointer.getPeer(V2), Pointer.getPeer(Mask), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildShuffleVector(@Ptr long LLVMBuilderRef1, @Ptr long V1, @Ptr long V2, @Ptr long Mask, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildExtractValue(LLVMBuilderRef, LLVMValueRef, unsigned, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildExtractValue(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef AggVal, int Index, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildExtractValue(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(AggVal), Index, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildExtractValue(@Ptr long LLVMBuilderRef1, @Ptr long AggVal, int Index, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildInsertValue(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, unsigned, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildInsertValue(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef AggVal, LLVMLibrary.LLVMValueRef EltVal, int Index, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildInsertValue(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(AggVal), Pointer.getPeer(EltVal), Index, Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildInsertValue(@Ptr long LLVMBuilderRef1, @Ptr long AggVal, @Ptr long EltVal, int Index, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildIsNull(LLVMBuilderRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildIsNull(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIsNull(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildIsNull(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildIsNotNull(LLVMBuilderRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildIsNotNull(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef Val, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildIsNotNull(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(Val), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildIsNotNull(@Ptr long LLVMBuilderRef1, @Ptr long Val, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildPtrDiff(LLVMBuilderRef, LLVMValueRef, LLVMValueRef, const char*)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildPtrDiff(LLVMLibrary.LLVMBuilderRef LLVMBuilderRef1, LLVMLibrary.LLVMValueRef LHS, LLVMLibrary.LLVMValueRef RHS, Pointer<Byte > Name) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildPtrDiff(Pointer.getPeer(LLVMBuilderRef1), Pointer.getPeer(LHS), Pointer.getPeer(RHS), Pointer.getPeer(Name)));
	}
	@Ptr 
	protected native static long LLVMBuildPtrDiff(@Ptr long LLVMBuilderRef1, @Ptr long LHS, @Ptr long RHS, @Ptr long Name);
	/// Original signature : <code>LLVMValueRef LLVMBuildAtomicRMW(LLVMBuilderRef, LLVMAtomicRMWBinOp, LLVMValueRef, LLVMValueRef, LLVMAtomicOrdering, LLVMBool)</code>
	public static LLVMLibrary.LLVMValueRef LLVMBuildAtomicRMW(LLVMLibrary.LLVMBuilderRef B, IntValuedEnum<LLVMLibrary.LLVMAtomicRMWBinOp > op, LLVMLibrary.LLVMValueRef PTR, LLVMLibrary.LLVMValueRef Val, IntValuedEnum<LLVMLibrary.LLVMAtomicOrdering > ordering, int singleThread) {
		return new LLVMLibrary.LLVMValueRef(LLVMBuildAtomicRMW(Pointer.getPeer(B), (int)op.value(), Pointer.getPeer(PTR), Pointer.getPeer(Val), (int)ordering.value(), singleThread));
	}
	@Ptr 
	protected native static long LLVMBuildAtomicRMW(@Ptr long B, int op, @Ptr long PTR, @Ptr long Val, int ordering, int singleThread);
	/**
	 * Changes the type of M so it can be passed to FunctionPassManagers and the<br>
	 * JIT.  They take ModuleProviders for historical reasons.<br>
	 * Original signature : <code>LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMModuleProviderRef LLVMCreateModuleProviderForExistingModule(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMModuleProviderRef(LLVMCreateModuleProviderForExistingModule(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMCreateModuleProviderForExistingModule(@Ptr long M);
	/**
	 * Destroys the module M.<br>
	 * Original signature : <code>void LLVMDisposeModuleProvider(LLVMModuleProviderRef)</code>
	 */
	public static void LLVMDisposeModuleProvider(LLVMLibrary.LLVMModuleProviderRef M) {
		LLVMDisposeModuleProvider(Pointer.getPeer(M));
	}
	protected native static void LLVMDisposeModuleProvider(@Ptr long M);
	/// Original signature : <code>LLVMBool LLVMCreateMemoryBufferWithContentsOfFile(const char*, LLVMMemoryBufferRef*, char**)</code>
	public static int LLVMCreateMemoryBufferWithContentsOfFile(Pointer<Byte > Path, Pointer<LLVMLibrary.LLVMMemoryBufferRef > OutMemBuf, Pointer<Pointer<Byte > > OutMessage) {
		return LLVMCreateMemoryBufferWithContentsOfFile(Pointer.getPeer(Path), Pointer.getPeer(OutMemBuf), Pointer.getPeer(OutMessage));
	}
	protected native static int LLVMCreateMemoryBufferWithContentsOfFile(@Ptr long Path, @Ptr long OutMemBuf, @Ptr long OutMessage);
	/// Original signature : <code>LLVMBool LLVMCreateMemoryBufferWithSTDIN(LLVMMemoryBufferRef*, char**)</code>
	public static int LLVMCreateMemoryBufferWithSTDIN(Pointer<LLVMLibrary.LLVMMemoryBufferRef > OutMemBuf, Pointer<Pointer<Byte > > OutMessage) {
		return LLVMCreateMemoryBufferWithSTDIN(Pointer.getPeer(OutMemBuf), Pointer.getPeer(OutMessage));
	}
	protected native static int LLVMCreateMemoryBufferWithSTDIN(@Ptr long OutMemBuf, @Ptr long OutMessage);
	/// Original signature : <code>LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(const char*, size_t, const char*, LLVMBool)</code>
	public static LLVMLibrary.LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRange(Pointer<Byte > InputData, @Ptr long InputDataLength, Pointer<Byte > BufferName, int RequiresNullTerminator) {
		return new LLVMLibrary.LLVMMemoryBufferRef(LLVMCreateMemoryBufferWithMemoryRange(Pointer.getPeer(InputData), InputDataLength, Pointer.getPeer(BufferName), RequiresNullTerminator));
	}
	@Ptr 
	protected native static long LLVMCreateMemoryBufferWithMemoryRange(@Ptr long InputData, @Ptr long InputDataLength, @Ptr long BufferName, int RequiresNullTerminator);
	/// Original signature : <code>LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(const char*, size_t, const char*)</code>
	public static LLVMLibrary.LLVMMemoryBufferRef LLVMCreateMemoryBufferWithMemoryRangeCopy(Pointer<Byte > InputData, @Ptr long InputDataLength, Pointer<Byte > BufferName) {
		return new LLVMLibrary.LLVMMemoryBufferRef(LLVMCreateMemoryBufferWithMemoryRangeCopy(Pointer.getPeer(InputData), InputDataLength, Pointer.getPeer(BufferName)));
	}
	@Ptr 
	protected native static long LLVMCreateMemoryBufferWithMemoryRangeCopy(@Ptr long InputData, @Ptr long InputDataLength, @Ptr long BufferName);
	/// Original signature : <code>char* LLVMGetBufferStart(LLVMMemoryBufferRef)</code>
	public static Pointer<Byte > LLVMGetBufferStart(LLVMLibrary.LLVMMemoryBufferRef MemBuf) {
		return Pointer.pointerToAddress(LLVMGetBufferStart(Pointer.getPeer(MemBuf)), Byte.class);
	}
	@Ptr 
	protected native static long LLVMGetBufferStart(@Ptr long MemBuf);
	/// Original signature : <code>size_t LLVMGetBufferSize(LLVMMemoryBufferRef)</code>
	@Ptr 
	public static long LLVMGetBufferSize(LLVMLibrary.LLVMMemoryBufferRef MemBuf) {
		return LLVMGetBufferSize(Pointer.getPeer(MemBuf));
	}
	@Ptr 
	protected native static long LLVMGetBufferSize(@Ptr long MemBuf);
	/// Original signature : <code>void LLVMDisposeMemoryBuffer(LLVMMemoryBufferRef)</code>
	public static void LLVMDisposeMemoryBuffer(LLVMLibrary.LLVMMemoryBufferRef MemBuf) {
		LLVMDisposeMemoryBuffer(Pointer.getPeer(MemBuf));
	}
	protected native static void LLVMDisposeMemoryBuffer(@Ptr long MemBuf);
	/**
	 * Return the global pass registry, for use with initialization functions.<br>
	 * @see llvm::PassRegistry::getPassRegistry<br>
	 * Original signature : <code>LLVMPassRegistryRef LLVMGetGlobalPassRegistry()</code>
	 */
	public static LLVMLibrary.LLVMPassRegistryRef LLVMGetGlobalPassRegistry() {
		return new LLVMLibrary.LLVMPassRegistryRef(LLVMGetGlobalPassRegistry$2());
	}
	@Ptr 
	@Name("LLVMGetGlobalPassRegistry") 
	protected native static long LLVMGetGlobalPassRegistry$2();
	/**
	 * Constructs a new whole-module pass pipeline. This type of pipeline is<br>
	 * suitable for link-time optimization and whole-module transformations.<br>
	 * @see llvm::PassManager::PassManager<br>
	 * Original signature : <code>LLVMPassManagerRef LLVMCreatePassManager()</code>
	 */
	public static LLVMLibrary.LLVMPassManagerRef LLVMCreatePassManager() {
		return new LLVMLibrary.LLVMPassManagerRef(LLVMCreatePassManager$2());
	}
	@Ptr 
	@Name("LLVMCreatePassManager") 
	protected native static long LLVMCreatePassManager$2();
	/**
	 * Constructs a new function-by-function pass pipeline over the module<br>
	 * provider. It does not take ownership of the module provider. This type of<br>
	 * pipeline is suitable for code generation and JIT compilation tasks.<br>
	 * @see llvm::FunctionPassManager::FunctionPassManager<br>
	 * Original signature : <code>LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMModuleRef)</code>
	 */
	public static LLVMLibrary.LLVMPassManagerRef LLVMCreateFunctionPassManagerForModule(LLVMLibrary.LLVMModuleRef M) {
		return new LLVMLibrary.LLVMPassManagerRef(LLVMCreateFunctionPassManagerForModule(Pointer.getPeer(M)));
	}
	@Ptr 
	protected native static long LLVMCreateFunctionPassManagerForModule(@Ptr long M);
	/**
	 * Deprecated: Use LLVMCreateFunctionPassManagerForModule instead.<br>
	 * Original signature : <code>LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMModuleProviderRef)</code>
	 */
	public static LLVMLibrary.LLVMPassManagerRef LLVMCreateFunctionPassManager(LLVMLibrary.LLVMModuleProviderRef MP) {
		return new LLVMLibrary.LLVMPassManagerRef(LLVMCreateFunctionPassManager(Pointer.getPeer(MP)));
	}
	@Ptr 
	protected native static long LLVMCreateFunctionPassManager(@Ptr long MP);
	/**
	 * Initializes, executes on the provided module, and finalizes all of the<br>
	 * passes scheduled in the pass manager. Returns 1 if any of the passes<br>
	 * modified the module, 0 otherwise.<br>
	 * @see llvm::PassManager::run(Module&)<br>
	 * Original signature : <code>LLVMBool LLVMRunPassManager(LLVMPassManagerRef, LLVMModuleRef)</code>
	 */
	public static int LLVMRunPassManager(LLVMLibrary.LLVMPassManagerRef PM, LLVMLibrary.LLVMModuleRef M) {
		return LLVMRunPassManager(Pointer.getPeer(PM), Pointer.getPeer(M));
	}
	protected native static int LLVMRunPassManager(@Ptr long PM, @Ptr long M);
	/**
	 * Initializes all of the function passes scheduled in the function pass<br>
	 * manager. Returns 1 if any of the passes modified the module, 0 otherwise.<br>
	 * @see llvm::FunctionPassManager::doInitialization<br>
	 * Original signature : <code>LLVMBool LLVMInitializeFunctionPassManager(LLVMPassManagerRef)</code>
	 */
	public static int LLVMInitializeFunctionPassManager(LLVMLibrary.LLVMPassManagerRef FPM) {
		return LLVMInitializeFunctionPassManager(Pointer.getPeer(FPM));
	}
	protected native static int LLVMInitializeFunctionPassManager(@Ptr long FPM);
	/**
	 * Executes all of the function passes scheduled in the function pass manager<br>
	 * on the provided function. Returns 1 if any of the passes modified the<br>
	 * function, false otherwise.<br>
	 * @see llvm::FunctionPassManager::run(Function&)<br>
	 * Original signature : <code>LLVMBool LLVMRunFunctionPassManager(LLVMPassManagerRef, LLVMValueRef)</code>
	 */
	public static int LLVMRunFunctionPassManager(LLVMLibrary.LLVMPassManagerRef FPM, LLVMLibrary.LLVMValueRef F) {
		return LLVMRunFunctionPassManager(Pointer.getPeer(FPM), Pointer.getPeer(F));
	}
	protected native static int LLVMRunFunctionPassManager(@Ptr long FPM, @Ptr long F);
	/**
	 * Finalizes all of the function passes scheduled in in the function pass<br>
	 * manager. Returns 1 if any of the passes modified the module, 0 otherwise.<br>
	 * @see llvm::FunctionPassManager::doFinalization<br>
	 * Original signature : <code>LLVMBool LLVMFinalizeFunctionPassManager(LLVMPassManagerRef)</code>
	 */
	public static int LLVMFinalizeFunctionPassManager(LLVMLibrary.LLVMPassManagerRef FPM) {
		return LLVMFinalizeFunctionPassManager(Pointer.getPeer(FPM));
	}
	protected native static int LLVMFinalizeFunctionPassManager(@Ptr long FPM);
	/**
	 * Frees the memory of a pass pipeline. For function pipelines, does not free<br>
	 * the module provider.<br>
	 * @see llvm::PassManagerBase::~PassManagerBase.<br>
	 * Original signature : <code>void LLVMDisposePassManager(LLVMPassManagerRef)</code>
	 */
	public static void LLVMDisposePassManager(LLVMLibrary.LLVMPassManagerRef PM) {
		LLVMDisposePassManager(Pointer.getPeer(PM));
	}
	protected native static void LLVMDisposePassManager(@Ptr long PM);
	/**
	 * Allocate and initialize structures needed to make LLVM safe for<br>
	 * multithreading. The return value indicates whether multithreaded<br>
	 * initialization succeeded. Must be executed in isolation from all<br>
	 * other LLVM api calls.<br>
	 * @see llvm::llvm_start_multithreaded<br>
	 * Original signature : <code>LLVMBool LLVMStartMultithreaded()</code>
	 */
	native public static int LLVMStartMultithreaded();
	/**
	 * Deallocate structures necessary to make LLVM safe for multithreading.<br>
	 * Must be executed in isolation from all other LLVM api calls.<br>
	 * @see llvm::llvm_stop_multithreaded<br>
	 * Original signature : <code>void LLVMStopMultithreaded()</code>
	 */
	native public static void LLVMStopMultithreaded();
	/**
	 * Check whether LLVM is executing in thread-safe mode or not.<br>
	 * @see llvm::llvm_is_multithreaded<br>
	 * Original signature : <code>LLVMBool LLVMIsMultithreaded()</code>
	 */
	native public static int LLVMIsMultithreaded();
	/**
	 * Create a disassembler for the TripleName.  Symbolic disassembly is supported<br>
	 * by passing a block of information in the DisInfo parameter and specifying the<br>
	 * TagType and callback functions as described above.  These can all be passed<br>
	 * as NULL.  If successful, this returns a disassembler context.  If not, it<br>
	 * returns NULL. This function is equivalent to calling LLVMCreateDisasmCPU()<br>
	 * with an empty CPU name.<br>
	 * Original signature : <code>LLVMDisasmContextRef LLVMCreateDisasm(const char*, void*, int, LLVMOpInfoCallback, LLVMSymbolLookupCallback)</code>
	 */
	public static Pointer<? > LLVMCreateDisasm(Pointer<Byte > TripleName, Pointer<? > DisInfo, int TagType, Pointer<LLVMLibrary.LLVMOpInfoCallback > GetOpInfo, Pointer<LLVMLibrary.LLVMSymbolLookupCallback > SymbolLookUp) {
		return Pointer.pointerToAddress(LLVMCreateDisasm(Pointer.getPeer(TripleName), Pointer.getPeer(DisInfo), TagType, Pointer.getPeer(GetOpInfo), Pointer.getPeer(SymbolLookUp)));
	}
	@Ptr 
	protected native static long LLVMCreateDisasm(@Ptr long TripleName, @Ptr long DisInfo, int TagType, @Ptr long GetOpInfo, @Ptr long SymbolLookUp);
	/**
	 * Create a disassembler for the TripleName and a specific CPU.  Symbolic<br>
	 * disassembly is supported by passing a block of information in the DisInfo<br>
	 * parameter and specifying the TagType and callback functions as described<br>
	 * above.  These can all be passed * as NULL.  If successful, this returns a<br>
	 * disassembler context.  If not, it returns NULL.<br>
	 * Original signature : <code>LLVMDisasmContextRef LLVMCreateDisasmCPU(const char*, const char*, void*, int, LLVMOpInfoCallback, LLVMSymbolLookupCallback)</code>
	 */
	public static Pointer<? > LLVMCreateDisasmCPU(Pointer<Byte > Triple, Pointer<Byte > CPU, Pointer<? > DisInfo, int TagType, Pointer<LLVMLibrary.LLVMOpInfoCallback > GetOpInfo, Pointer<LLVMLibrary.LLVMSymbolLookupCallback > SymbolLookUp) {
		return Pointer.pointerToAddress(LLVMCreateDisasmCPU(Pointer.getPeer(Triple), Pointer.getPeer(CPU), Pointer.getPeer(DisInfo), TagType, Pointer.getPeer(GetOpInfo), Pointer.getPeer(SymbolLookUp)));
	}
	@Ptr 
	protected native static long LLVMCreateDisasmCPU(@Ptr long Triple, @Ptr long CPU, @Ptr long DisInfo, int TagType, @Ptr long GetOpInfo, @Ptr long SymbolLookUp);
	/**
	 * Set the disassembler's options.  Returns 1 if it can set the Options and 0<br>
	 * otherwise.<br>
	 * Original signature : <code>int LLVMSetDisasmOptions(LLVMDisasmContextRef, uint64_t)</code>
	 */
	public static int LLVMSetDisasmOptions(Pointer<? > DC, long Options) {
		return LLVMSetDisasmOptions(Pointer.getPeer(DC), Options);
	}
	protected native static int LLVMSetDisasmOptions(@Ptr long DC, long Options);
	/**
	 * Dispose of a disassembler context.<br>
	 * Original signature : <code>void LLVMDisasmDispose(LLVMDisasmContextRef)</code>
	 */
	public static void LLVMDisasmDispose(Pointer<? > DC) {
		LLVMDisasmDispose(Pointer.getPeer(DC));
	}
	protected native static void LLVMDisasmDispose(@Ptr long DC);
	/**
	 * Disassemble a single instruction using the disassembler context specified in<br>
	 * the parameter DC.  The bytes of the instruction are specified in the<br>
	 * parameter Bytes, and contains at least BytesSize number of bytes.  The<br>
	 * instruction is at the address specified by the PC parameter.  If a valid<br>
	 * instruction can be disassembled, its string is returned indirectly in<br>
	 * OutString whose size is specified in the parameter OutStringSize.  This<br>
	 * function returns the number of bytes in the instruction or zero if there was<br>
	 * no valid instruction.<br>
	 * Original signature : <code>size_t LLVMDisasmInstruction(LLVMDisasmContextRef, uint8_t*, uint64_t, uint64_t, char*, size_t)</code>
	 */
	@Ptr 
	public static long LLVMDisasmInstruction(Pointer<? > DC, Pointer<Byte > Bytes, long BytesSize, long PC, Pointer<Byte > OutString, @Ptr long OutStringSize) {
		return LLVMDisasmInstruction(Pointer.getPeer(DC), Pointer.getPeer(Bytes), BytesSize, PC, Pointer.getPeer(OutString), OutStringSize);
	}
	@Ptr 
	protected native static long LLVMDisasmInstruction(@Ptr long DC, @Ptr long Bytes, long BytesSize, long PC, @Ptr long OutString, @Ptr long OutStringSize);
	/// Original signature : <code>void LLVMLinkInJIT()</code>
	native public static void LLVMLinkInJIT();
	/// Original signature : <code>void LLVMLinkInMCJIT()</code>
	native public static void LLVMLinkInMCJIT();
	/// Original signature : <code>void LLVMLinkInInterpreter()</code>
	native public static void LLVMLinkInInterpreter();
	/// Original signature : <code>LLVMGenericValueRef LLVMCreateGenericValueOfInt(LLVMTypeRef, unsigned long long, LLVMBool)</code>
	public static LLVMLibrary.LLVMGenericValueRef LLVMCreateGenericValueOfInt(LLVMLibrary.LLVMTypeRef Ty, long N, int IsSigned) {
		return new LLVMLibrary.LLVMGenericValueRef(LLVMCreateGenericValueOfInt(Pointer.getPeer(Ty), N, IsSigned));
	}
	@Ptr 
	protected native static long LLVMCreateGenericValueOfInt(@Ptr long Ty, long N, int IsSigned);
	/// Original signature : <code>LLVMGenericValueRef LLVMCreateGenericValueOfPointer(void*)</code>
	public static LLVMLibrary.LLVMGenericValueRef LLVMCreateGenericValueOfPointer(Pointer<? > P) {
		return new LLVMLibrary.LLVMGenericValueRef(LLVMCreateGenericValueOfPointer(Pointer.getPeer(P)));
	}
	@Ptr 
	protected native static long LLVMCreateGenericValueOfPointer(@Ptr long P);
	/// Original signature : <code>LLVMGenericValueRef LLVMCreateGenericValueOfFloat(LLVMTypeRef, double)</code>
	public static LLVMLibrary.LLVMGenericValueRef LLVMCreateGenericValueOfFloat(LLVMLibrary.LLVMTypeRef Ty, double N) {
		return new LLVMLibrary.LLVMGenericValueRef(LLVMCreateGenericValueOfFloat(Pointer.getPeer(Ty), N));
	}
	@Ptr 
	protected native static long LLVMCreateGenericValueOfFloat(@Ptr long Ty, double N);
	/// Original signature : <code>int LLVMGenericValueIntWidth(LLVMGenericValueRef)</code>
	public static int LLVMGenericValueIntWidth(LLVMLibrary.LLVMGenericValueRef GenValRef) {
		return LLVMGenericValueIntWidth(Pointer.getPeer(GenValRef));
	}
	protected native static int LLVMGenericValueIntWidth(@Ptr long GenValRef);
	/// Original signature : <code>long long LLVMGenericValueToInt(LLVMGenericValueRef, LLVMBool)</code>
	public static long LLVMGenericValueToInt(LLVMLibrary.LLVMGenericValueRef GenVal, int IsSigned) {
		return LLVMGenericValueToInt(Pointer.getPeer(GenVal), IsSigned);
	}
	protected native static long LLVMGenericValueToInt(@Ptr long GenVal, int IsSigned);
	/// Original signature : <code>void* LLVMGenericValueToPointer(LLVMGenericValueRef)</code>
	public static Pointer<? > LLVMGenericValueToPointer(LLVMLibrary.LLVMGenericValueRef GenVal) {
		return Pointer.pointerToAddress(LLVMGenericValueToPointer(Pointer.getPeer(GenVal)));
	}
	@Ptr 
	protected native static long LLVMGenericValueToPointer(@Ptr long GenVal);
	/// Original signature : <code>double LLVMGenericValueToFloat(LLVMTypeRef, LLVMGenericValueRef)</code>
	public static double LLVMGenericValueToFloat(LLVMLibrary.LLVMTypeRef TyRef, LLVMLibrary.LLVMGenericValueRef GenVal) {
		return LLVMGenericValueToFloat(Pointer.getPeer(TyRef), Pointer.getPeer(GenVal));
	}
	protected native static double LLVMGenericValueToFloat(@Ptr long TyRef, @Ptr long GenVal);
	/// Original signature : <code>void LLVMDisposeGenericValue(LLVMGenericValueRef)</code>
	public static void LLVMDisposeGenericValue(LLVMLibrary.LLVMGenericValueRef GenVal) {
		LLVMDisposeGenericValue(Pointer.getPeer(GenVal));
	}
	protected native static void LLVMDisposeGenericValue(@Ptr long GenVal);
	/// Original signature : <code>LLVMBool LLVMCreateExecutionEngineForModule(LLVMExecutionEngineRef*, LLVMModuleRef, char**)</code>
	public static int LLVMCreateExecutionEngineForModule(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutEE, LLVMLibrary.LLVMModuleRef M, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateExecutionEngineForModule(Pointer.getPeer(OutEE), Pointer.getPeer(M), Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateExecutionEngineForModule(@Ptr long OutEE, @Ptr long M, @Ptr long OutError);
	/// Original signature : <code>LLVMBool LLVMCreateInterpreterForModule(LLVMExecutionEngineRef*, LLVMModuleRef, char**)</code>
	public static int LLVMCreateInterpreterForModule(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutInterp, LLVMLibrary.LLVMModuleRef M, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateInterpreterForModule(Pointer.getPeer(OutInterp), Pointer.getPeer(M), Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateInterpreterForModule(@Ptr long OutInterp, @Ptr long M, @Ptr long OutError);
	/// Original signature : <code>LLVMBool LLVMCreateJITCompilerForModule(LLVMExecutionEngineRef*, LLVMModuleRef, unsigned, char**)</code>
	public static int LLVMCreateJITCompilerForModule(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutJIT, LLVMLibrary.LLVMModuleRef M, int OptLevel, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateJITCompilerForModule(Pointer.getPeer(OutJIT), Pointer.getPeer(M), OptLevel, Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateJITCompilerForModule(@Ptr long OutJIT, @Ptr long M, int OptLevel, @Ptr long OutError);
	/// Original signature : <code>void LLVMInitializeMCJITCompilerOptions(LLVMMCJITCompilerOptions*, size_t)</code>
	public static void LLVMInitializeMCJITCompilerOptions(Pointer<LLVMMCJITCompilerOptions > Options, @Ptr long SizeOfOptions) {
		LLVMInitializeMCJITCompilerOptions(Pointer.getPeer(Options), SizeOfOptions);
	}
	protected native static void LLVMInitializeMCJITCompilerOptions(@Ptr long Options, @Ptr long SizeOfOptions);
	/**
	 * Create an MCJIT execution engine for a module, with the given options. It is<br>
	 * the responsibility of the caller to ensure that all fields in Options up to<br>
	 * the given SizeOfOptions are initialized. It is correct to pass a smaller<br>
	 * value of SizeOfOptions that omits some fields. The canonical way of using<br>
	 * this is:<br>
	 * * LLVMMCJITCompilerOptions options;<br>
	 * LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));<br>
	 * ... fill in those options you care about<br>
	 * LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),<br>
	 *                                  &error);<br>
	 * * Note that this is also correct, though possibly suboptimal:<br>
	 * * LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);<br>
	 * Original signature : <code>LLVMBool LLVMCreateMCJITCompilerForModule(LLVMExecutionEngineRef*, LLVMModuleRef, LLVMMCJITCompilerOptions*, size_t, char**)</code>
	 */
	public static int LLVMCreateMCJITCompilerForModule(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutJIT, LLVMLibrary.LLVMModuleRef M, Pointer<LLVMMCJITCompilerOptions > Options, @Ptr long SizeOfOptions, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateMCJITCompilerForModule(Pointer.getPeer(OutJIT), Pointer.getPeer(M), Pointer.getPeer(Options), SizeOfOptions, Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateMCJITCompilerForModule(@Ptr long OutJIT, @Ptr long M, @Ptr long Options, @Ptr long SizeOfOptions, @Ptr long OutError);
	/**
	 * Deprecated: Use LLVMCreateExecutionEngineForModule instead.<br>
	 * Original signature : <code>LLVMBool LLVMCreateExecutionEngine(LLVMExecutionEngineRef*, LLVMModuleProviderRef, char**)</code>
	 */
	public static int LLVMCreateExecutionEngine(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutEE, LLVMLibrary.LLVMModuleProviderRef MP, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateExecutionEngine(Pointer.getPeer(OutEE), Pointer.getPeer(MP), Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateExecutionEngine(@Ptr long OutEE, @Ptr long MP, @Ptr long OutError);
	/**
	 * Deprecated: Use LLVMCreateInterpreterForModule instead.<br>
	 * Original signature : <code>LLVMBool LLVMCreateInterpreter(LLVMExecutionEngineRef*, LLVMModuleProviderRef, char**)</code>
	 */
	public static int LLVMCreateInterpreter(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutInterp, LLVMLibrary.LLVMModuleProviderRef MP, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateInterpreter(Pointer.getPeer(OutInterp), Pointer.getPeer(MP), Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateInterpreter(@Ptr long OutInterp, @Ptr long MP, @Ptr long OutError);
	/**
	 * Deprecated: Use LLVMCreateJITCompilerForModule instead.<br>
	 * Original signature : <code>LLVMBool LLVMCreateJITCompiler(LLVMExecutionEngineRef*, LLVMModuleProviderRef, unsigned, char**)</code>
	 */
	public static int LLVMCreateJITCompiler(Pointer<LLVMLibrary.LLVMExecutionEngineRef > OutJIT, LLVMLibrary.LLVMModuleProviderRef MP, int OptLevel, Pointer<Pointer<Byte > > OutError) {
		return LLVMCreateJITCompiler(Pointer.getPeer(OutJIT), Pointer.getPeer(MP), OptLevel, Pointer.getPeer(OutError));
	}
	protected native static int LLVMCreateJITCompiler(@Ptr long OutJIT, @Ptr long MP, int OptLevel, @Ptr long OutError);
	/// Original signature : <code>void LLVMDisposeExecutionEngine(LLVMExecutionEngineRef)</code>
	public static void LLVMDisposeExecutionEngine(LLVMLibrary.LLVMExecutionEngineRef EE) {
		LLVMDisposeExecutionEngine(Pointer.getPeer(EE));
	}
	protected native static void LLVMDisposeExecutionEngine(@Ptr long EE);
	/// Original signature : <code>void LLVMRunStaticConstructors(LLVMExecutionEngineRef)</code>
	public static void LLVMRunStaticConstructors(LLVMLibrary.LLVMExecutionEngineRef EE) {
		LLVMRunStaticConstructors(Pointer.getPeer(EE));
	}
	protected native static void LLVMRunStaticConstructors(@Ptr long EE);
	/// Original signature : <code>void LLVMRunStaticDestructors(LLVMExecutionEngineRef)</code>
	public static void LLVMRunStaticDestructors(LLVMLibrary.LLVMExecutionEngineRef EE) {
		LLVMRunStaticDestructors(Pointer.getPeer(EE));
	}
	protected native static void LLVMRunStaticDestructors(@Ptr long EE);
	/// Original signature : <code>int LLVMRunFunctionAsMain(LLVMExecutionEngineRef, LLVMValueRef, unsigned, const const char**, const const char**)</code>
	public static int LLVMRunFunctionAsMain(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef F, int ArgC, Pointer<Pointer<Byte > > ArgV, Pointer<Pointer<Byte > > EnvP) {
		return LLVMRunFunctionAsMain(Pointer.getPeer(EE), Pointer.getPeer(F), ArgC, Pointer.getPeer(ArgV), Pointer.getPeer(EnvP));
	}
	protected native static int LLVMRunFunctionAsMain(@Ptr long EE, @Ptr long F, int ArgC, @Ptr long ArgV, @Ptr long EnvP);
	/// Original signature : <code>LLVMGenericValueRef LLVMRunFunction(LLVMExecutionEngineRef, LLVMValueRef, unsigned, LLVMGenericValueRef*)</code>
	public static LLVMLibrary.LLVMGenericValueRef LLVMRunFunction(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef F, int NumArgs, Pointer<LLVMLibrary.LLVMGenericValueRef > Args) {
		return new LLVMLibrary.LLVMGenericValueRef(LLVMRunFunction(Pointer.getPeer(EE), Pointer.getPeer(F), NumArgs, Pointer.getPeer(Args)));
	}
	@Ptr 
	protected native static long LLVMRunFunction(@Ptr long EE, @Ptr long F, int NumArgs, @Ptr long Args);
	/// Original signature : <code>void LLVMFreeMachineCodeForFunction(LLVMExecutionEngineRef, LLVMValueRef)</code>
	public static void LLVMFreeMachineCodeForFunction(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef F) {
		LLVMFreeMachineCodeForFunction(Pointer.getPeer(EE), Pointer.getPeer(F));
	}
	protected native static void LLVMFreeMachineCodeForFunction(@Ptr long EE, @Ptr long F);
	/// Original signature : <code>void LLVMAddModule(LLVMExecutionEngineRef, LLVMModuleRef)</code>
	public static void LLVMAddModule(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMModuleRef M) {
		LLVMAddModule(Pointer.getPeer(EE), Pointer.getPeer(M));
	}
	protected native static void LLVMAddModule(@Ptr long EE, @Ptr long M);
	/**
	 * Deprecated: Use LLVMAddModule instead.<br>
	 * Original signature : <code>void LLVMAddModuleProvider(LLVMExecutionEngineRef, LLVMModuleProviderRef)</code>
	 */
	public static void LLVMAddModuleProvider(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMModuleProviderRef MP) {
		LLVMAddModuleProvider(Pointer.getPeer(EE), Pointer.getPeer(MP));
	}
	protected native static void LLVMAddModuleProvider(@Ptr long EE, @Ptr long MP);
	/// Original signature : <code>LLVMBool LLVMRemoveModule(LLVMExecutionEngineRef, LLVMModuleRef, LLVMModuleRef*, char**)</code>
	public static int LLVMRemoveModule(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMModuleRef M, Pointer<LLVMLibrary.LLVMModuleRef > OutMod, Pointer<Pointer<Byte > > OutError) {
		return LLVMRemoveModule(Pointer.getPeer(EE), Pointer.getPeer(M), Pointer.getPeer(OutMod), Pointer.getPeer(OutError));
	}
	protected native static int LLVMRemoveModule(@Ptr long EE, @Ptr long M, @Ptr long OutMod, @Ptr long OutError);
	/**
	 * Deprecated: Use LLVMRemoveModule instead.<br>
	 * Original signature : <code>LLVMBool LLVMRemoveModuleProvider(LLVMExecutionEngineRef, LLVMModuleProviderRef, LLVMModuleRef*, char**)</code>
	 */
	public static int LLVMRemoveModuleProvider(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMModuleProviderRef MP, Pointer<LLVMLibrary.LLVMModuleRef > OutMod, Pointer<Pointer<Byte > > OutError) {
		return LLVMRemoveModuleProvider(Pointer.getPeer(EE), Pointer.getPeer(MP), Pointer.getPeer(OutMod), Pointer.getPeer(OutError));
	}
	protected native static int LLVMRemoveModuleProvider(@Ptr long EE, @Ptr long MP, @Ptr long OutMod, @Ptr long OutError);
	/// Original signature : <code>LLVMBool LLVMFindFunction(LLVMExecutionEngineRef, const char*, LLVMValueRef*)</code>
	public static int LLVMFindFunction(LLVMLibrary.LLVMExecutionEngineRef EE, Pointer<Byte > Name, Pointer<LLVMLibrary.LLVMValueRef > OutFn) {
		return LLVMFindFunction(Pointer.getPeer(EE), Pointer.getPeer(Name), Pointer.getPeer(OutFn));
	}
	protected native static int LLVMFindFunction(@Ptr long EE, @Ptr long Name, @Ptr long OutFn);
	/// Original signature : <code>void* LLVMRecompileAndRelinkFunction(LLVMExecutionEngineRef, LLVMValueRef)</code>
	public static Pointer<? > LLVMRecompileAndRelinkFunction(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef Fn) {
		return Pointer.pointerToAddress(LLVMRecompileAndRelinkFunction(Pointer.getPeer(EE), Pointer.getPeer(Fn)));
	}
	@Ptr 
	protected native static long LLVMRecompileAndRelinkFunction(@Ptr long EE, @Ptr long Fn);
	/// Original signature : <code>LLVMTargetDataRef LLVMGetExecutionEngineTargetData(LLVMExecutionEngineRef)</code>
	public static LLVMLibrary.LLVMTargetDataRef LLVMGetExecutionEngineTargetData(LLVMLibrary.LLVMExecutionEngineRef EE) {
		return Pointer.pointerToAddress(LLVMGetExecutionEngineTargetData(Pointer.getPeer(EE)));
	}
	@Ptr 
	protected native static long LLVMGetExecutionEngineTargetData(@Ptr long EE);
	/// Original signature : <code>void LLVMAddGlobalMapping(LLVMExecutionEngineRef, LLVMValueRef, void*)</code>
	public static void LLVMAddGlobalMapping(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef Global, Pointer<? > Addr) {
		LLVMAddGlobalMapping(Pointer.getPeer(EE), Pointer.getPeer(Global), Pointer.getPeer(Addr));
	}
	protected native static void LLVMAddGlobalMapping(@Ptr long EE, @Ptr long Global, @Ptr long Addr);
	/// Original signature : <code>void* LLVMGetPointerToGlobal(LLVMExecutionEngineRef, LLVMValueRef)</code>
	public static Pointer<? > LLVMGetPointerToGlobal(LLVMLibrary.LLVMExecutionEngineRef EE, LLVMLibrary.LLVMValueRef Global) {
		return Pointer.pointerToAddress(LLVMGetPointerToGlobal(Pointer.getPeer(EE), Pointer.getPeer(Global)));
	}
	@Ptr 
	protected native static long LLVMGetPointerToGlobal(@Ptr long EE, @Ptr long Global);
	public static class LLVMContextRef extends TypedPointer {
		public LLVMContextRef(long address) {
			super(address);
		}
		public LLVMContextRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMValueRef extends TypedPointer {
		public LLVMValueRef(long address) {
			super(address);
		}
		public LLVMValueRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMPassManagerRef extends TypedPointer {
		public LLVMPassManagerRef(long address) {
			super(address);
		}
		public LLVMPassManagerRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMTypeRef extends TypedPointer {
		public LLVMTypeRef(long address) {
			super(address);
		}
		public LLVMTypeRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMModuleProviderRef extends TypedPointer {
		public LLVMModuleProviderRef(long address) {
			super(address);
		}
		public LLVMModuleProviderRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMModuleRef extends TypedPointer {
		public LLVMModuleRef(long address) {
			super(address);
		}
		public LLVMModuleRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMGenericValueRef extends TypedPointer {
		public LLVMGenericValueRef(long address) {
			super(address);
		}
		public LLVMGenericValueRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMUseRef extends TypedPointer {
		public LLVMUseRef(long address) {
			super(address);
		}
		public LLVMUseRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMExecutionEngineRef extends TypedPointer {
		public LLVMExecutionEngineRef(long address) {
			super(address);
		}
		public LLVMExecutionEngineRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMBasicBlockRef extends TypedPointer {
		public LLVMBasicBlockRef(long address) {
			super(address);
		}
		public LLVMBasicBlockRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMMemoryBufferRef extends TypedPointer {
		public LLVMMemoryBufferRef(long address) {
			super(address);
		}
		public LLVMMemoryBufferRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMPassRegistryRef extends TypedPointer {
		public LLVMPassRegistryRef(long address) {
			super(address);
		}
		public LLVMPassRegistryRef(Pointer address) {
			super(address);
		}
	};
	public static class LLVMBuilderRef extends TypedPointer {
		public LLVMBuilderRef(long address) {
			super(address);
		}
		public LLVMBuilderRef(Pointer address) {
			super(address);
		}
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaquePassManager {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueBasicBlock {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueMemoryBuffer {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueGenericValue {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueValue {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueUse {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueModule {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueType {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueModuleProvider {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMCodeModel {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueBuilder {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueContext {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaquePassRegistry {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMOpaqueExecutionEngine {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface LLVMTargetDataRef {
		
	};
}
